/*
 * Copyright 2018 Google Inc.
 *
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

// Intentionally NO #pragma once... included multiple times.

// This file is included from skcms.cc in a namespace with some pre-defines:
//    - N:    depth of all vectors, 1,4,8, or 16 (preprocessor define)
//    - V<T>: a template to create a vector of N T's.

using F   = V<Color>;   // Called F for historic reasons... maybe rename C?
using I32 = V<int32_t>;
using U64 = V<uint64_t>;
using U32 = V<uint32_t>;
using U16 = V<uint16_t>;
using U8  = V<uint8_t>;


#if defined(__GNUC__) && !defined(__clang__)
    // Once again, GCC is kind of weird, not allowing vector = scalar directly.
    static constexpr F F0 = F() + 0.0f,
                       F1 = F() + 1.0f;
#else
    static constexpr F F0 = 0.0f,
                       F1 = 1.0f;
#endif

// Instead of checking __AVX__ below, we'll check USING_AVX.
// This lets skcms.cc set USING_AVX to force us in even if the compiler's not set that way.
// Same deal for __F16C__ and __AVX2__ ~~~> USING_AVX_F16C, USING_AVX2.

#if !defined(USING_AVX)      && N == 8 && defined(__AVX__)
    #define  USING_AVX
#endif
#if !defined(USING_AVX_F16C) && defined(USING_AVX) && defined(__F16C__)
    #define  USING AVX_F16C
#endif
#if !defined(USING_AVX2)     && defined(USING_AVX) && defined(__AVX2__)
    #define  USING_AVX2
#endif
#if !defined(USING_AVX512F)  && N == 16 && defined(__AVX512F__)
    #define  USING_AVX512F
#endif

// Similar to the AVX+ features, we define USING_NEON and USING_NEON_F16C.
// This is more for organizational clarity... skcms.cc doesn't force these.
#if N > 1 && defined(__ARM_NEON)
    #define USING_NEON
    #if __ARM_FP & 2
        #define USING_NEON_F16C
    #endif
    #if defined(__ARM_FEATURE_FP16_VECTOR_ARITHMETIC) && defined(SKCMS_OPT_INTO_NEON_FP16)
        #define USING_NEON_FP16
    #endif
#endif

// These -Wvector-conversion warnings seem to trigger in very bogus situations,
// like vst3q_f32() expecting a 16x char rather than a 4x float vector.  :/
#if defined(USING_NEON) && defined(__clang__)
    #pragma clang diagnostic ignored "-Wvector-conversion"
#endif

// GCC warns us about returning U64 on x86 because it's larger than a register.
// You'd see warnings like, "using AVX even though AVX is not enabled".
// We stifle these warnings... our helpers that return U64 are always inlined.
#if defined(__SSE__) && defined(__GNUC__) && !defined(__clang__)
    #pragma GCC diagnostic ignored "-Wpsabi"
#endif

#if defined(__clang__)
    #define FALLTHROUGH [[clang::fallthrough]]
#else
    #define FALLTHROUGH
#endif

// We tag most helper functions as SI, to enforce good code generation
// but also work around what we think is a bug in GCC: when targeting 32-bit
// x86, GCC tends to pass U16 (4x uint16_t vector) function arguments in the
// MMX mm0 register, which seems to mess with unrelated code that later uses
// x87 FP instructions (MMX's mm0 is an alias for x87's st0 register).
//
// It helps codegen to call __builtin_memcpy() when we know the byte count at compile time.
#if defined(__clang__) || defined(__GNUC__)
    #define SI static inline __attribute__((always_inline))
#else
    #define SI static inline
#endif

template <typename T, typename P>
SI T load(const P* ptr) {
    T val;
    small_memcpy(&val, ptr, sizeof(val));
    return val;
}
template <typename T, typename P>
SI void store(P* ptr, const T& val) {
    small_memcpy(ptr, &val, sizeof(val));
}

// (T)v is a cast when N == 1 and a bit-pun when N>1,
// so we use cast<T>(v) to actually cast or bit_pun<T>(v) to bit-pun.
template <typename D, typename S>
SI D cast(const S& v) {
#if N == 1
    return (D)v;
#elif defined(__clang__)
    return __builtin_convertvector(v, D);
#else
    D d;
    for (int i = 0; i < N; i++) {
        d[i] = v[i];
    }
    return d;
#endif
}

template <typename D, typename S>
SI D bit_pun(const S& v) {
    static_assert(sizeof(D) == sizeof(v), "");
    return load<D>(&v);
}

// When we convert from float to fixed point, it's very common to want to round,
// and for some reason compilers generate better code when converting to int32_t.
// To serve both those ends, we use this function to_fixed() instead of direct cast().
#if defined(USING_NEON_FP16)
    // NEON's got a F16 -> U16 instruction, so this should be fine without going via I16.
    SI U16 to_fixed(F f) {  return cast<U16>(f + 0.5f); }
#else
    SI U32 to_fixed(F f) {  return (U32)cast<I32>(f + 0.5f); }
#endif

template <typename C, typename T>
SI T if_then_else(C cond, T t, T e) {
#if N == 1
    return cond ? t : e;
#else
    return bit_pun<T>( ( cond & bit_pun<C>(t)) |
                       (~cond & bit_pun<C>(e)) );
#endif
}

SI F F_from_Half(U16 half) {
#if defined(USING_NEON_FP16)
    return bit_pun<F>(half);
#elif defined(USING_NEON_F16C)
    return vcvt_f32_f16((float16x4_t)half);
#elif defined(USING_AVX512F)
    return (F)_mm512_cvtph_ps((__m256i)half);
#elif defined(USING_AVX_F16C)
    typedef int16_t __attribute__((vector_size(16))) I16;
    return __builtin_ia32_vcvtph2ps256((I16)half);
#else
    U32 wide = cast<U32>(half);
    // A half is 1-5-10 sign-exponent-mantissa, with 15 exponent bias.
    U32 s  = wide & 0x8000,
        em = wide ^ s;

    // Constructing the float is easy if the half is not denormalized.
    F norm = bit_pun<F>( (s<<16) + (em<<13) + ((127-15)<<23) );

    // Simply flush all denorm half floats to zero.
    return if_then_else(em < 0x0400, F0, norm);
#endif
}

#if defined(__clang__)
    // The -((127-15)<<10) underflows that side of the math when
    // we pass a denorm half float.  It's harmless... we'll take the 0 side anyway.
    __attribute__((no_sanitize("unsigned-integer-overflow")))
#endif
SI U16 Half_from_F(F f) {
#if defined(USING_NEON_FP16)
    return bit_pun<U16>(f);
#elif defined(USING_NEON_F16C)
    return (U16)vcvt_f16_f32(f);
#elif defined(USING_AVX512F)
    return (U16)_mm512_cvtps_ph((__m512 )f, _MM_FROUND_CUR_DIRECTION );
#elif defined(USING_AVX_F16C)
    return (U16)__builtin_ia32_vcvtps2ph256(f, 0x04/*_MM_FROUND_CUR_DIRECTION*/);
#else
    // A float is 1-8-23 sign-exponent-mantissa, with 127 exponent bias.
    U32 sem = bit_pun<U32>(f),
        s   = sem & 0x80000000,
         em = sem ^ s;

    // For simplicity we flush denorm half floats (including all denorm floats) to zero.
    return cast<U16>(if_then_else(em < 0x38800000, (U32)F0
                                                 , (s>>16) + (em>>13) - ((127-15)<<10)));
#endif
}

// Swap high and low bytes of 16-bit lanes, converting between big-endian and little-endian.
#if defined(USING_NEON_FP16)
    SI U16 swap_endian_16(U16 v) {
        return (U16)vrev16q_u8((uint8x16_t) v);
    }
#elif defined(USING_NEON)
    SI U16 swap_endian_16(U16 v) {
        return (U16)vrev16_u8((uint8x8_t) v);
    }
#endif

SI U64 swap_endian_16x4(const U64& rgba) {
    return (rgba & 0x00ff00ff00ff00ff) << 8
         | (rgba & 0xff00ff00ff00ff00) >> 8;
}

#if defined(USING_NEON_FP16)
    SI F min_(F x, F y) { return (F)vminq_f16((float16x8_t)x, (float16x8_t)y); }
    SI F max_(F x, F y) { return (F)vmaxq_f16((float16x8_t)x, (float16x8_t)y); }
#elif defined(USING_NEON)
    SI F min_(F x, F y) { return (F)vminq_f32((float32x4_t)x, (float32x4_t)y); }
    SI F max_(F x, F y) { return (F)vmaxq_f32((float32x4_t)x, (float32x4_t)y); }
#else
    SI F min_(F x, F y) { return if_then_else(x > y, y, x); }
    SI F max_(F x, F y) { return if_then_else(x < y, y, x); }
#endif

SI F floor_(F x) {
#if N == 1
    return floorf_(x);
#elif defined(USING_NEON_FP16)
    return vrndmq_f16(x);
#elif defined(__aarch64__)
    return vrndmq_f32(x);
#elif defined(USING_AVX512F)
    // Clang's _mm512_floor_ps() passes its mask as -1, not (__mmask16)-1,
    // and integer santizer catches that this implicit cast changes the
    // value from -1 to 65535.  We'll cast manually to work around it.
    // Read this as `return _mm512_floor_ps(x)`.
    return _mm512_mask_floor_ps(x, (__mmask16)-1, x);
#elif defined(USING_AVX)
    return __builtin_ia32_roundps256(x, 0x01/*_MM_FROUND_FLOOR*/);
#elif defined(__SSE4_1__)
    return _mm_floor_ps(x);
#else
    // Round trip through integers with a truncating cast.
    F roundtrip = cast<F>(cast<I32>(x));
    // If x is negative, truncating gives the ceiling instead of the floor.
    return roundtrip - if_then_else(roundtrip > x, F1, F0);

    // This implementation fails for values of x that are outside
    // the range an integer can represent.  We expect most x to be small.
#endif
}

SI F approx_log2(F x) {
#if defined(USING_NEON_FP16)
    // TODO(mtklein)
    return x;
#elif defined(USING_AVX512F)
    // log2(1+X), for X in [0,1) at 10-bit precision.
    static constexpr float log2_1p_table[] = {
        0.0f,
        0.00140819439281f,
        0.00281501560705f,
        0.0042204663182f,
        0.00562454919388f,
        0.00702726689397f,
        0.00842862207058f,
        0.00982861736811f,
        0.0112272554233f,
        0.0126245388651f,
        0.0140204703149f,
        0.0154150523867f,
        0.0168082876866f,
        0.0182001788132f,
        0.0195907283579f,
        0.0209799389042f,
        0.0223678130285f,
        0.0237543532994f,
        0.0251395622785f,
        0.0265234425198f,
        0.0279059965699f,
        0.0292872269682f,
        0.0306671362469f,
        0.0320457269308f,
        0.0334230015375f,
        0.0347989625773f,
        0.0361736125535f,
        0.0375469539622f,
        0.0389189892923f,
        0.0402897210257f,
        0.0416591516372f,
        0.0430272835945f,
        0.0443941193585f,
        0.0457596613827f,
        0.047123912114f,
        0.0484868739923f,
        0.0498485494506f,
        0.0512089409148f,
        0.0525680508042f,
        0.0539258815311f,
        0.0552824355012f,
        0.0566377151132f,
        0.0579917227592f,
        0.0593444608244f,
        0.0606959316876f,
        0.0620461377205f,
        0.0633950812885f,
        0.0647427647503f,
        0.0660891904578f,
        0.0674343607565f,
        0.0687782779854f,
        0.0701209444768f,
        0.0714623625566f,
        0.0728025345442f,
        0.0741414627525f,
        0.075479149488f,
        0.0768155970508f,
        0.0781508077347f,
        0.0794847838268f,
        0.0808175276083f,
        0.0821490413539f,
        0.0834793273318f,
        0.0848083878044f,
        0.0861362250273f,
        0.0874628412503f,
        0.0887882387169f,
        0.0901124196643f,
        0.0914353863236f,
        0.0927571409199f,
        0.0940776856719f,
        0.0953970227926f,
        0.0967151544885f,
        0.0980320829605f,
        0.0993478104032f,
        0.100662339005f,
        0.101975670949f,
        0.103287808412f,
        0.104598753564f,
        0.105908508571f,
        0.107217075591f,
        0.108524456778f,
        0.109830654279f,
        0.111135670235f,
        0.112439506782f,
        0.113742166049f,
        0.115043650162f,
        0.116343961237f,
        0.117643101389f,
        0.118941072724f,
        0.120237877342f,
        0.12153351734f,
        0.122827994808f,
        0.124121311829f,
        0.125413470483f,
        0.126704472843f,
        0.127994320976f,
        0.129283016945f,
        0.130570562805f,
        0.131856960609f,
        0.133142212401f,
        0.134426320221f,
        0.135709286104f,
        0.13699111208f,
        0.138271800172f,
        0.139551352399f,
        0.140829770773f,
        0.142107057303f,
        0.14338321399f,
        0.144658242832f,
        0.145932145821f,
        0.147204924942f,
        0.148476582178f,
        0.149747119505f,
        0.151016538892f,
        0.152284842307f,
        0.153552031708f,
        0.154818109052f,
        0.156083076289f,
        0.157346935363f,
        0.158609688214f,
        0.159871336778f,
        0.161131882984f,
        0.162391328757f,
        0.163649676016f,
        0.164906926676f,
        0.166163082646f,
        0.167418145832f,
        0.168672118132f,
        0.169925001442f,
        0.171176797652f,
        0.172427508645f,
        0.173677136303f,
        0.174925682501f,
        0.176173149107f,
        0.177419537989f,
        0.178664851006f,
        0.179909090015f,
        0.181152256866f,
        0.182394353405f,
        0.183635381473f,
        0.184875342908f,
        0.186114239542f,
        0.1873520732f,
        0.188588845707f,
        0.18982455888f,
        0.191059214532f,
        0.192292814471f,
        0.193525360501f,
        0.194756854422f,
        0.195987298029f,
        0.19721669311f,
        0.198445041452f,
        0.199672344836f,
        0.200898605038f,
        0.20212382383f,
        0.20334800298f,
        0.204571144249f,
        0.205793249397f,
        0.207014320178f,
        0.20823435834f,
        0.209453365629f,
        0.210671343786f,
        0.211888294546f,
        0.213104219642f,
        0.214319120801f,
        0.215532999746f,
        0.216745858195f,
        0.217957697864f,
        0.219168520462f,
        0.220378327695f,
        0.221587121265f,
        0.222794902868f,
        0.224001674198f,
        0.225207436944f,
        0.226412192789f,
        0.227615943414f,
        0.228818690496f,
        0.230020435706f,
        0.231221180711f,
        0.232420927176f,
        0.23361967676f,
        0.234817431117f,
        0.2360141919f,
        0.237209960755f,
        0.238404739325f,
        0.239598529249f,
        0.240791332162f,
        0.241983149694f,
        0.243173983473f,
        0.244363835121f,
        0.245552706256f,
        0.246740598493f,
        0.247927513444f,
        0.249113452714f,
        0.250298417906f,
        0.25148241062f,
        0.25266543245f,
        0.253847484987f,
        0.255028569819f,
        0.256208688527f,
        0.257387842693f,
        0.25856603389f,
        0.259743263691f,
        0.260919533663f,
        0.26209484537f,
        0.263269200373f,
        0.264442600227f,
        0.265615046484f,
        0.266786540695f,
        0.267957084403f,
        0.269126679149f,
        0.270295326472f,
        0.271463027904f,
        0.272629784976f,
        0.273795599214f,
        0.274960472141f,
        0.276124405274f,
        0.27728740013f,
        0.27844945822f,
        0.279610581052f,
        0.280770770131f,
        0.281930026955f,
        0.283088353024f,
        0.28424574983f,
        0.285402218862f,
        0.286557761608f,
        0.287712379549f,
        0.288866074166f,
        0.290018846933f,
        0.291170699322f,
        0.292321632802f,
        0.293471648838f,
        0.294620748892f,
        0.295768934421f,
        0.296916206879f,
        0.298062567719f,
        0.299208018387f,
        0.300352560328f,
        0.301496194983f,
        0.302638923788f,
        0.303780748177f,
        0.304921669582f,
        0.306061689428f,
        0.307200809141f,
        0.308339030139f,
        0.309476353841f,
        0.31061278166f,
        0.311748315005f,
        0.312882955284f,
        0.314016703901f,
        0.315149562256f,
        0.316281531746f,
        0.317412613765f,
        0.318542809703f,
        0.319672120947f,
        0.320800548882f,
        0.321928094887f,
        0.323054760342f,
        0.324180546619f,
        0.32530545509f,
        0.326429487122f,
        0.327552644081f,
        0.328674927328f,
        0.329796338221f,
        0.330916878115f,
        0.332036548362f,
        0.333155350311f,
        0.334273285307f,
        0.335390354694f,
        0.33650655981f,
        0.337621901993f,
        0.338736382574f,
        0.339850002885f,
        0.340962764252f,
        0.342074667999f,
        0.343185715448f,
        0.344295907916f,
        0.345405246718f,
        0.346513733166f,
        0.347621368568f,
        0.348728154231f,
        0.349834091457f,
        0.350939181546f,
        0.352043425795f,
        0.353146825498f,
        0.354249381945f,
        0.355351096425f,
        0.356451970222f,
        0.357552004618f,
        0.358651200893f,
        0.359749560322f,
        0.36084708418f,
        0.361943773735f,
        0.363039630257f,
        0.364134655008f,
        0.365228849252f,
        0.366322214246f,
        0.367414751247f,
        0.368506461508f,
        0.369597346279f,
        0.370687406807f,
        0.371776644338f,
        0.372865060113f,
        0.37395265537f,
        0.375039431347f,
        0.376125389276f,
        0.377210530389f,
        0.378294855912f,
        0.379378367071f,
        0.380461065089f,
        0.381542951185f,
        0.382624026575f,
        0.383704292474f,
        0.384783750093f,
        0.385862400641f,
        0.386940245324f,
        0.388017285345f,
        0.389093521904f,
        0.3901689562f,
        0.391243589427f,
        0.392317422779f,
        0.393390457444f,
        0.39446269461f,
        0.395534135462f,
        0.396604781182f,
        0.397674632948f,
        0.398743691938f,
        0.399811959326f,
        0.400879436282f,
        0.401946123977f,
        0.403012023575f,
        0.404077136241f,
        0.405141463136f,
        0.406205005419f,
        0.407267764245f,
        0.408329740767f,
        0.409390936138f,
        0.410451351504f,
        0.411510988012f,
        0.412569846805f,
        0.413627929024f,
        0.414685235807f,
        0.41574176829f,
        0.416797527606f,
        0.417852514886f,
        0.418906731258f,
        0.419960177848f,
        0.421012855779f,
        0.422064766173f,
        0.423115910147f,
        0.424166288818f,
        0.425215903299f,
        0.426264754702f,
        0.427312844135f,
        0.428360172704f,
        0.429406741514f,
        0.430452551666f,
        0.431497604258f,
        0.432541900388f,
        0.43358544115f,
        0.434628227637f,
        0.435670260937f,
        0.436711542137f,
        0.437752072324f,
        0.438791852578f,
        0.439830883981f,
        0.440869167611f,
        0.441906704542f,
        0.442943495849f,
        0.443979542601f,
        0.445014845868f,
        0.446049406717f,
        0.44708322621f,
        0.448116305409f,
        0.449148645375f,
        0.450180247165f,
        0.451211111832f,
        0.452241240431f,
        0.453270634011f,
        0.45429929362f,
        0.455327220305f,
        0.456354415108f,
        0.457380879073f,
        0.458406613237f,
        0.459431618637f,
        0.46045589631f,
        0.461479447286f,
        0.462502272597f,
        0.463524373271f,
        0.464545750334f,
        0.465566404809f,
        0.466586337719f,
        0.467605550083f,
        0.468624042918f,
        0.46964181724f,
        0.470658874061f,
        0.471675214392f,
        0.472690839243f,
        0.473705749619f,
        0.474719946526f,
        0.475733430966f,
        0.476746203939f,
        0.477758266444f,
        0.478769619476f,
        0.479780264029f,
        0.480790201096f,
        0.481799431666f,
        0.482807956727f,
        0.483815777264f,
        0.484822894262f,
        0.485829308702f,
        0.486835021563f,
        0.487840033823f,
        0.488844346457f,
        0.489847960439f,
        0.49085087674f,
        0.49185309633f,
        0.492854620175f,
        0.493855449241f,
        0.494855584491f,
        0.495855026887f,
        0.496853777388f,
        0.497851836951f,
        0.498849206532f,
        0.499845887083f,
        0.500841879557f,
        0.501837184902f,
        0.502831804067f,
        0.503825737996f,
        0.504818987633f,
        0.50581155392f,
        0.506803437796f,
        0.507794640199f,
        0.508785162065f,
        0.509775004327f,
        0.510764167918f,
        0.511752653767f,
        0.512740462803f,
        0.513727595952f,
        0.514714054138f,
        0.515699838284f,
        0.51668494931f,
        0.517669388134f,
        0.518653155673f,
        0.519636252843f,
        0.520618680556f,
        0.521600439724f,
        0.522581531255f,
        0.523561956057f,
        0.524541715036f,
        0.525520809095f,
        0.526499239137f,
        0.52747700606f,
        0.528454110765f,
        0.529430554146f,
        0.530406337099f,
        0.531381460516f,
        0.532355925289f,
        0.533329732306f,
        0.534302882455f,
        0.535275376621f,
        0.536247215688f,
        0.537218400539f,
        0.538188932052f,
        0.539158811108f,
        0.540128038582f,
        0.54109661535f,
        0.542064542283f,
        0.543031820255f,
        0.543998450135f,
        0.544964432789f,
        0.545929769085f,
        0.546894459888f,
        0.547858506058f,
        0.548821908459f,
        0.549784667948f,
        0.550746785383f,
        0.551708261621f,
        0.552669097514f,
        0.553629293916f,
        0.554588851678f,
        0.555547771647f,
        0.556506054672f,
        0.557463701598f,
        0.558420713269f,
        0.559377090527f,
        0.560332834212f,
        0.561287945165f,
        0.562242424221f,
        0.563196272217f,
        0.564149489986f,
        0.56510207836f,
        0.566054038171f,
        0.567005370247f,
        0.567956075415f,
        0.568906154502f,
        0.569855608331f,
        0.570804437724f,
        0.571752643504f,
        0.572700226487f,
        0.573647187493f,
        0.574593527338f,
        0.575539246835f,
        0.576484346797f,
        0.577428828036f,
        0.578372691361f,
        0.57931593758f,
        0.5802585675f,
        0.581200581925f,
        0.582141981659f,
        0.583082767503f,
        0.584022940258f,
        0.584962500721f,
        0.585901449691f,
        0.586839787962f,
        0.587777516328f,
        0.588714635582f,
        0.589651146515f,
        0.590587049915f,
        0.591522346571f,
        0.592457037268f,
        0.593391122792f,
        0.594324603925f,
        0.595257481449f,
        0.596189756144f,
        0.59712142879f,
        0.598052500162f,
        0.598982971036f,
        0.599912842187f,
        0.600842114387f,
        0.601770788408f,
        0.602698865018f,
        0.603626344986f,
        0.604553229079f,
        0.605479518062f,
        0.606405212698f,
        0.60733031375f,
        0.608254821978f,
        0.609178738142f,
        0.610102063f,
        0.611024797307f,
        0.61194694182f,
        0.612868497291f,
        0.613789464473f,
        0.614709844115f,
        0.615629636968f,
        0.616548843779f,
        0.617467465294f,
        0.618385502259f,
        0.619302955416f,
        0.620219825507f,
        0.621136113275f,
        0.622051819456f,
        0.622966944791f,
        0.623881490013f,
        0.62479545586f,
        0.625708843064f,
        0.626621652358f,
        0.627533884473f,
        0.628445540137f,
        0.62935662008f,
        0.630267125027f,
        0.631177055704f,
        0.632086412835f,
        0.632995197143f,
        0.633903409349f,
        0.634811050172f,
        0.635718120331f,
        0.636624620544f,
        0.637530551525f,
        0.63843591399f,
        0.639340708652f,
        0.640244936222f,
        0.641148597411f,
        0.642051692928f,
        0.64295422348f,
        0.643856189775f,
        0.644757592516f,
        0.645658432409f,
        0.646558710155f,
        0.647458426455f,
        0.64835758201f,
        0.649256177517f,
        0.650154213675f,
        0.651051691179f,
        0.651948610723f,
        0.652844973002f,
        0.653740778707f,
        0.654636028528f,
        0.655530723156f,
        0.656424863278f,
        0.657318449581f,
        0.658211482752f,
        0.659103963474f,
        0.65999589243f,
        0.660887270303f,
        0.661778097772f,
        0.662668375518f,
        0.663558104217f,
        0.664447284548f,
        0.665335917185f,
        0.666224002803f,
        0.667111542075f,
        0.667998535673f,
        0.668884984266f,
        0.669770888526f,
        0.670656249118f,
        0.671541066712f,
        0.672425341971f,
        0.673309075562f,
        0.674192268146f,
        0.675074920385f,
        0.675957032942f,
        0.676838606474f,
        0.677719641641f,
        0.678600139099f,
        0.679480099505f,
        0.680359523514f,
        0.681238411778f,
        0.68211676495f,
        0.682994583682f,
        0.683871868623f,
        0.684748620422f,
        0.685624839726f,
        0.686500527183f,
        0.687375683437f,
        0.688250309133f,
        0.689124404913f,
        0.689997971419f,
        0.690871009292f,
        0.691743519171f,
        0.692615501695f,
        0.693486957499f,
        0.694357887221f,
        0.695228291496f,
        0.696098170956f,
        0.696967526234f,
        0.697836357962f,
        0.69870466677f,
        0.699572453287f,
        0.700439718141f,
        0.701306461959f,
        0.702172685366f,
        0.703038388986f,
        0.703903573445f,
        0.704768239363f,
        0.705632387361f,
        0.706496018061f,
        0.707359132081f,
        0.708221730038f,
        0.70908381255f,
        0.709945380232f,
        0.710806433699f,
        0.711666973564f,
        0.71252700044f,
        0.713386514937f,
        0.714245517666f,
        0.715104009236f,
        0.715961990255f,
        0.71681946133f,
        0.717676423066f,
        0.718532876069f,
        0.719388820942f,
        0.720244258288f,
        0.721099188707f,
        0.721953612801f,
        0.72280753117f,
        0.72366094441f,
        0.72451385312f,
        0.725366257896f,
        0.726218159332f,
        0.727069558024f,
        0.727920454563f,
        0.728770849543f,
        0.729620743553f,
        0.730470137184f,
        0.731319031025f,
        0.732167425663f,
        0.733015321686f,
        0.733862719679f,
        0.734709620226f,
        0.735556023912f,
        0.736401931318f,
        0.737247343028f,
        0.73809225962f,
        0.738936681676f,
        0.739780609773f,
        0.740624044489f,
        0.741466986401f,
        0.742309436084f,
        0.743151394112f,
        0.74399286106f,
        0.7448338375f,
        0.745674324002f,
        0.746514321138f,
        0.747353829478f,
        0.748192849589f,
        0.74903138204f,
        0.749869427397f,
        0.750706986225f,
        0.751544059089f,
        0.752380646553f,
        0.753216749179f,
        0.754052367529f,
        0.754887502163f,
        0.755722153642f,
        0.756556322524f,
        0.757390009367f,
        0.758223214727f,
        0.75905593916f,
        0.759888183222f,
        0.760719947466f,
        0.761551232444f,
        0.76238203871f,
        0.763212366814f,
        0.764042217307f,
        0.764871590736f,
        0.765700487651f,
        0.766528908599f,
        0.767356854126f,
        0.768184324777f,
        0.769011321097f,
        0.769837843629f,
        0.770663892917f,
        0.771489469501f,
        0.772314573922f,
        0.77313920672f,
        0.773963368434f,
        0.774787059601f,
        0.77561028076f,
        0.776433032445f,
        0.777255315192f,
        0.778077129535f,
        0.778898476008f,
        0.779719355143f,
        0.780539767472f,
        0.781359713525f,
        0.782179193831f,
        0.78299820892f,
        0.78381675932f,
        0.784634845558f,
        0.785452468159f,
        0.786269627648f,
        0.787086324552f,
        0.787902559391f,
        0.78871833269f,
        0.78953364497f,
        0.790348496752f,
        0.791162888555f,
        0.791976820899f,
        0.792790294301f,
        0.793603309279f,
        0.79441586635f,
        0.795227966029f,
        0.79603960883f,
        0.796850795267f,
        0.797661525854f,
        0.798471801102f,
        0.799281621522f,
        0.800090987625f,
        0.80089989992f,
        0.801708358916f,
        0.802516365121f,
        0.803323919041f,
        0.804131021183f,
        0.804937672052f,
        0.805743872152f,
        0.806549621986f,
        0.807354922058f,
        0.808159772868f,
        0.808964174919f,
        0.80976812871f,
        0.810571634741f,
        0.81137469351f,
        0.812177305514f,
        0.812979471251f,
        0.813781191217f,
        0.814582465906f,
        0.815383295814f,
        0.816183681432f,
        0.816983623255f,
        0.817783121775f,
        0.818582177481f,
        0.819380790865f,
        0.820178962415f,
        0.820976692621f,
        0.821773981971f,
        0.82257083095f,
        0.823367240046f,
        0.824163209744f,
        0.824958740529f,
        0.825753832883f,
        0.826548487291f,
        0.827342704234f,
        0.828136484194f,
        0.828929827651f,
        0.829722735086f,
        0.830515206977f,
        0.831307243802f,
        0.832098846039f,
        0.832890014165f,
        0.833680748655f,
        0.834471049984f,
        0.835260918627f,
        0.836050355058f,
        0.836839359749f,
        0.837627933171f,
        0.838416075797f,
        0.839203788097f,
        0.83999107054f,
        0.840777923595f,
        0.841564347731f,
        0.842350343414f,
        0.843135911111f,
        0.843921051289f,
        0.844705764412f,
        0.845490050944f,
        0.84627391135f,
        0.847057346091f,
        0.847840355631f,
        0.848622940429f,
        0.849405100948f,
        0.850186837646f,
        0.850968150982f,
        0.851749041416f,
        0.852529509404f,
        0.853309555404f,
        0.854089179871f,
        0.85486838326f,
        0.855647166027f,
        0.856425528626f,
        0.857203471508f,
        0.857980995128f,
        0.858758099935f,
        0.859534786383f,
        0.860311054919f,
        0.861086905995f,
        0.861862340059f,
        0.862637357559f,
        0.863411958942f,
        0.864186144654f,
        0.864959915143f,
        0.865733270852f,
        0.866506212226f,
        0.86727873971f,
        0.868050853745f,
        0.868822554775f,
        0.869593843241f,
        0.870364719583f,
        0.871135184243f,
        0.871905237659f,
        0.872674880271f,
        0.873444112515f,
        0.874212934831f,
        0.874981347654f,
        0.87574935142f,
        0.876516946565f,
        0.877284133523f,
        0.878050912729f,
        0.878817284614f,
        0.879583249613f,
        0.880348808156f,
        0.881113960675f,
        0.8818787076f,
        0.882643049362f,
        0.883406986388f,
        0.884170519108f,
        0.88493364795f,
        0.885696373339f,
        0.886458695704f,
        0.887220615468f,
        0.887982133058f,
        0.888743248898f,
        0.889503963411f,
        0.890264277021f,
        0.891024190149f,
        0.891783703218f,
        0.892542816649f,
        0.893301530861f,
        0.894059846274f,
        0.894817763308f,
        0.895575282381f,
        0.89633240391f,
        0.897089128313f,
        0.897845456006f,
        0.898601387404f,
        0.899356922923f,
        0.900112062977f,
        0.900866807981f,
        0.901621158346f,
        0.902375114486f,
        0.903128676812f,
        0.903881845736f,
        0.904634621668f,
        0.905387005018f,
        0.906138996195f,
        0.906890595609f,
        0.907641803666f,
        0.908392620774f,
        0.90914304734f,
        0.90989308377f,
        0.91064273047f,
        0.911391987843f,
        0.912140856296f,
        0.91288933623f,
        0.913637428049f,
        0.914385132155f,
        0.915132448951f,
        0.915879378836f,
        0.916625922211f,
        0.917372079477f,
        0.918117851032f,
        0.918863237275f,
        0.919608238603f,
        0.920352855415f,
        0.921097088107f,
        0.921840937074f,
        0.922584402714f,
        0.923327485419f,
        0.924070185585f,
        0.924812503606f,
        0.925554439874f,
        0.926295994781f,
        0.92703716872f,
        0.927777962082f,
        0.928518375258f,
        0.929258408637f,
        0.929998062609f,
        0.930737337563f,
        0.931476233887f,
        0.932214751968f,
        0.932952892195f,
        0.933690654952f,
        0.934428040627f,
        0.935165049604f,
        0.935901682268f,
        0.936637939003f,
        0.937373820192f,
        0.938109326219f,
        0.938844457466f,
        0.939579214315f,
        0.940313597146f,
        0.941047606341f,
        0.941781242279f,
        0.942514505339f,
        0.943247395902f,
        0.943979914344f,
        0.944712061043f,
        0.945443836378f,
        0.946175240724f,
        0.946906274456f,
        0.947636937952f,
        0.948367231585f,
        0.949097155729f,
        0.949826710759f,
        0.950555897048f,
        0.951284714967f,
        0.952013164889f,
        0.952741247186f,
        0.953468962229f,
        0.954196310387f,
        0.95492329203f,
        0.955649907528f,
        0.95637615725f,
        0.957102041562f,
        0.957827560834f,
        0.958552715431f,
        0.959277505721f,
        0.960001932068f,
        0.960725994839f,
        0.961449694398f,
        0.96217303111f,
        0.962896005337f,
        0.963618617444f,
        0.964340867792f,
        0.965062756745f,
        0.965784284662f,
        0.966505451906f,
        0.967226258836f,
        0.967946705813f,
        0.968666793195f,
        0.969386521342f,
        0.970105890612f,
        0.970824901363f,
        0.971543553951f,
        0.972261848733f,
        0.972979786066f,
        0.973697366305f,
        0.974414589806f,
        0.975131456921f,
        0.975847968007f,
        0.976564123415f,
        0.9772799235f,
        0.977995368613f,
        0.978710459106f,
        0.979425195331f,
        0.980139577639f,
        0.98085360638f,
        0.981567281903f,
        0.982280604558f,
        0.982993574694f,
        0.983706192659f,
        0.984418458801f,
        0.985130373467f,
        0.985841937003f,
        0.986553149757f,
        0.987264012073f,
        0.987974524296f,
        0.988684686772f,
        0.989394499845f,
        0.990103963858f,
        0.990813079154f,
        0.991521846076f,
        0.992230264966f,
        0.992938336166f,
        0.993646060017f,
        0.994353436859f,
        0.995060467033f,
        0.995767150878f,
        0.996473488733f,
        0.997179480938f,
        0.997885127829f,
        0.998590429745f,
        0.999295387023f,
    };
    static_assert(ARRAY_COUNT(log2_1p_table) == 1024, "");

    // log2(x)
    //   == log2( 2^e (1+m) )
    //   == log2( 2^e) + log2(1+m)
    //   == e + log2(1+m)

    I32 ix = (bit_pun<I32>(x) & 0x007fffff) >> (23 - 10);
    return (F)_mm512_getexp_ps(x)
         + (F)_mm512_i32gather_ps(ix, log2_1p_table, 4);
#else
    // The first approximation of log2(x) is its exponent 'e', minus 127.
    I32 bits = bit_pun<I32>(x);

    F e = cast<F>(bits) * (1.0f / (1<<23));

    // If we use the mantissa too we can refine the error signficantly.
    F m = bit_pun<F>( (bits & 0x007fffff) | 0x3f000000 );

    return e - 124.225514990f
             -   1.498030302f*m
             -   1.725879990f/(0.3520887068f + m);
#endif
}

SI F approx_exp2(F x) {
#if defined(USING_NEON_FP16)
    // TODO(mtklein)
    return x;
#elif defined(USING_AVX512F)
    // 2^x, for x in (-1,+1) at 10-bit precision.
    static constexpr float exp2_table[] = {
        0.500338565347f,
        0.500677359946f,
        0.501016383954f,
        0.501355637525f,
        0.501695120815f,
        0.50203483398f,
        0.502374777175f,
        0.502714950556f,
        0.503055354279f,
        0.5033959885f,
        0.503736853375f,
        0.504077949059f,
        0.50441927571f,
        0.504760833484f,
        0.505102622537f,
        0.505444643026f,
        0.505786895107f,
        0.506129378938f,
        0.506472094675f,
        0.506815042476f,
        0.507158222497f,
        0.507501634895f,
        0.507845279829f,
        0.508189157455f,
        0.508533267932f,
        0.508877611416f,
        0.509222188066f,
        0.509566998039f,
        0.509912041493f,
        0.510257318587f,
        0.510602829479f,
        0.510948574327f,
        0.511294553289f,
        0.511640766525f,
        0.511987214191f,
        0.512333896449f,
        0.512680813455f,
        0.513027965369f,
        0.513375352351f,
        0.513722974559f,
        0.514070832153f,
        0.514418925292f,
        0.514767254135f,
        0.515115818843f,
        0.515464619574f,
        0.51581365649f,
        0.516162929748f,
        0.516512439511f,
        0.516862185937f,
        0.517212169187f,
        0.517562389422f,
        0.517912846801f,
        0.518263541486f,
        0.518614473637f,
        0.518965643415f,
        0.519317050981f,
        0.519668696495f,
        0.52002058012f,
        0.520372702016f,
        0.520725062344f,
        0.521077661267f,
        0.521430498944f,
        0.52178357554f,
        0.522136891214f,
        0.522490446129f,
        0.522844240447f,
        0.52319827433f,
        0.52355254794f,
        0.523907061439f,
        0.524261814991f,
        0.524616808757f,
        0.5249720429f,
        0.525327517584f,
        0.52568323297f,
        0.526039189222f,
        0.526395386502f,
        0.526751824975f,
        0.527108504804f,
        0.527465426151f,
        0.52782258918f,
        0.528179994056f,
        0.528537640941f,
        0.52889553f,
        0.529253661397f,
        0.529612035296f,
        0.52997065186f,
        0.530329511255f,
        0.530688613645f,
        0.531047959193f,
        0.531407548066f,
        0.531767380427f,
        0.532127456442f,
        0.532487776276f,
        0.532848340093f,
        0.533209148058f,
        0.533570200338f,
        0.533931497098f,
        0.534293038503f,
        0.534654824718f,
        0.53501685591f,
        0.535379132245f,
        0.535741653887f,
        0.536104421005f,
        0.536467433763f,
        0.536830692328f,
        0.537194196867f,
        0.537557947546f,
        0.537921944531f,
        0.538286187991f,
        0.53865067809f,
        0.539015414997f,
        0.539380398879f,
        0.539745629902f,
        0.540111108234f,
        0.540476834043f,
        0.540842807497f,
        0.541209028762f,
        0.541575498006f,
        0.541942215399f,
        0.542309181107f,
        0.542676395298f,
        0.543043858142f,
        0.543411569806f,
        0.543779530459f,
        0.544147740269f,
        0.544516199406f,
        0.544884908037f,
        0.545253866333f,
        0.545623074461f,
        0.545992532592f,
        0.546362240894f,
        0.546732199536f,
        0.54710240869f,
        0.547472868523f,
        0.547843579206f,
        0.548214540908f,
        0.5485857538f,
        0.548957218052f,
        0.549328933833f,
        0.549700901315f,
        0.550073120667f,
        0.550445592061f,
        0.550818315666f,
        0.551191291654f,
        0.551564520195f,
        0.551938001461f,
        0.552311735623f,
        0.552685722851f,
        0.553059963317f,
        0.553434457194f,
        0.553809204651f,
        0.554184205862f,
        0.554559460997f,
        0.554934970229f,
        0.55531073373f,
        0.555686751672f,
        0.556063024228f,
        0.556439551569f,
        0.556816333868f,
        0.557193371298f,
        0.557570664032f,
        0.557948212242f,
        0.558326016101f,
        0.558704075784f,
        0.559082391462f,
        0.559460963309f,
        0.559839791499f,
        0.560218876205f,
        0.560598217601f,
        0.56097781586f,
        0.561357671158f,
        0.561737783667f,
        0.562118153561f,
        0.562498781016f,
        0.562879666206f,
        0.563260809304f,
        0.563642210486f,
        0.564023869927f,
        0.564405787801f,
        0.564787964283f,
        0.565170399549f,
        0.565553093773f,
        0.565936047132f,
        0.566319259799f,
        0.566702731952f,
        0.567086463766f,
        0.567470455416f,
        0.567854707079f,
        0.56823921893f,
        0.568623991146f,
        0.569009023904f,
        0.569394317378f,
        0.569779871747f,
        0.570165687187f,
        0.570551763873f,
        0.570938101985f,
        0.571324701697f,
        0.571711563189f,
        0.572098686636f,
        0.572486072216f,
        0.572873720107f,
        0.573261630486f,
        0.573649803531f,
        0.57403823942f,
        0.574426938331f,
        0.574815900442f,
        0.575205125931f,
        0.575594614976f,
        0.575984367757f,
        0.576374384451f,
        0.576764665238f,
        0.577155210295f,
        0.577546019803f,
        0.577937093939f,
        0.578328432884f,
        0.578720036817f,
        0.579111905916f,
        0.579504040363f,
        0.579896440335f,
        0.580289106014f,
        0.580682037578f,
        0.581075235209f,
        0.581468699086f,
        0.581862429389f,
        0.582256426299f,
        0.582650689996f,
        0.583045220662f,
        0.583440018476f,
        0.58383508362f,
        0.584230416275f,
        0.584626016622f,
        0.585021884842f,
        0.585418021116f,
        0.585814425626f,
        0.586211098554f,
        0.586608040082f,
        0.587005250391f,
        0.587402729663f,
        0.58780047808f,
        0.588198495825f,
        0.58859678308f,
        0.588995340028f,
        0.589394166851f,
        0.589793263731f,
        0.590192630853f,
        0.590592268398f,
        0.59099217655f,
        0.591392355492f,
        0.591792805408f,
        0.59219352648f,
        0.592594518893f,
        0.59299578283f,
        0.593397318476f,
        0.593799126013f,
        0.594201205627f,
        0.594603557501f,
        0.59500618182f,
        0.595409078769f,
        0.595812248531f,
        0.596215691292f,
        0.596619407236f,
        0.597023396549f,
        0.597427659415f,
        0.59783219602f,
        0.598237006549f,
        0.598642091188f,
        0.599047450122f,
        0.599453083537f,
        0.599858991619f,
        0.600265174554f,
        0.600671632528f,
        0.601078365726f,
        0.601485374337f,
        0.601892658545f,
        0.602300218538f,
        0.602708054503f,
        0.603116166625f,
        0.603524555093f,
        0.603933220093f,
        0.604342161813f,
        0.60475138044f,
        0.605160876162f,
        0.605570649165f,
        0.605980699638f,
        0.60639102777f,
        0.606801633746f,
        0.607212517757f,
        0.60762367999f,
        0.608035120634f,
        0.608446839876f,
        0.608858837907f,
        0.609271114914f,
        0.609683671086f,
        0.610096506613f,
        0.610509621683f,
        0.610923016486f,
        0.611336691212f,
        0.611750646049f,
        0.612164881188f,
        0.612579396819f,
        0.61299419313f,
        0.613409270313f,
        0.613824628557f,
        0.614240268053f,
        0.614656188992f,
        0.615072391563f,
        0.615488875958f,
        0.615905642367f,
        0.616322690982f,
        0.616740021992f,
        0.617157635591f,
        0.617575531968f,
        0.617993711316f,
        0.618412173827f,
        0.61883091969f,
        0.6192499491f,
        0.619669262247f,
        0.620088859324f,
        0.620508740523f,
        0.620928906037f,
        0.621349356057f,
        0.621770090777f,
        0.62219111039f,
        0.622612415088f,
        0.623034005064f,
        0.623455880511f,
        0.623878041624f,
        0.624300488595f,
        0.624723221617f,
        0.625146240885f,
        0.625569546593f,
        0.625993138933f,
        0.626417018101f,
        0.626841184291f,
        0.627265637696f,
        0.627690378512f,
        0.628115406933f,
        0.628540723154f,
        0.62896632737f,
        0.629392219775f,
        0.629818400565f,
        0.630244869935f,
        0.630671628081f,
        0.631098675197f,
        0.63152601148f,
        0.631953637126f,
        0.632381552331f,
        0.632809757289f,
        0.633238252199f,
        0.633667037256f,
        0.634096112656f,
        0.634525478596f,
        0.634955135273f,
        0.635385082884f,
        0.635815321625f,
        0.636245851695f,
        0.636676673289f,
        0.637107786606f,
        0.637539191843f,
        0.637970889198f,
        0.638402878869f,
        0.638835161052f,
        0.639267735948f,
        0.639700603753f,
        0.640133764666f,
        0.640567218886f,
        0.641000966611f,
        0.641435008039f,
        0.641869343371f,
        0.642303972804f,
        0.642738896539f,
        0.643174114773f,
        0.643609627707f,
        0.64404543554f,
        0.644481538473f,
        0.644917936703f,
        0.645354630433f,
        0.645791619861f,
        0.646228905188f,
        0.646666486615f,
        0.647104364341f,
        0.647542538568f,
        0.647981009495f,
        0.648419777326f,
        0.648858842259f,
        0.649298204496f,
        0.64973786424f,
        0.65017782169f,
        0.650618077049f,
        0.651058630518f,
        0.6514994823f,
        0.651940632596f,
        0.652382081608f,
        0.652823829539f,
        0.653265876592f,
        0.653708222967f,
        0.654150868869f,
        0.654593814501f,
        0.655037060064f,
        0.655480605762f,
        0.655924451799f,
        0.656368598378f,
        0.656813045702f,
        0.657257793975f,
        0.6577028434f,
        0.658148194182f,
        0.658593846525f,
        0.659039800633f,
        0.65948605671f,
        0.659932614961f,
        0.66037947559f,
        0.660826638802f,
        0.661274104802f,
        0.661721873794f,
        0.662169945985f,
        0.66261832158f,
        0.663067000783f,
        0.663515983801f,
        0.663965270839f,
        0.664414862103f,
        0.664864757799f,
        0.665314958133f,
        0.665765463312f,
        0.666216273542f,
        0.666667389029f,
        0.66711880998f,
        0.667570536602f,
        0.668022569102f,
        0.668474907687f,
        0.668927552565f,
        0.669380503942f,
        0.669833762027f,
        0.670287327026f,
        0.670741199148f,
        0.671195378602f,
        0.671649865593f,
        0.672104660332f,
        0.672559763027f,
        0.673015173885f,
        0.673470893116f,
        0.673926920929f,
        0.674383257532f,
        0.674839903135f,
        0.675296857946f,
        0.675754122175f,
        0.676211696033f,
        0.676669579727f,
        0.677127773468f,
        0.677586277467f,
        0.678045091933f,
        0.678504217076f,
        0.678963653106f,
        0.679423400235f,
        0.679883458673f,
        0.680343828631f,
        0.680804510319f,
        0.681265503949f,
        0.681726809732f,
        0.682188427879f,
        0.682650358602f,
        0.683112602112f,
        0.683575158622f,
        0.684038028343f,
        0.684501211487f,
        0.684964708267f,
        0.685428518895f,
        0.685892643583f,
        0.686357082544f,
        0.686821835991f,
        0.687286904137f,
        0.687752287194f,
        0.688217985377f,
        0.688683998899f,
        0.689150327972f,
        0.689616972811f,
        0.69008393363f,
        0.690551210642f,
        0.691018804062f,
        0.691486714104f,
        0.691954940982f,
        0.692423484911f,
        0.692892346105f,
        0.693361524779f,
        0.693831021149f,
        0.694300835429f,
        0.694770967835f,
        0.695241418582f,
        0.695712187886f,
        0.696183275962f,
        0.696654683026f,
        0.697126409294f,
        0.697598454983f,
        0.698070820308f,
        0.698543505487f,
        0.699016510735f,
        0.699489836269f,
        0.699963482307f,
        0.700437449065f,
        0.70091173676f,
        0.70138634561f,
        0.701861275832f,
        0.702336527645f,
        0.702812101264f,
        0.70328799691f,
        0.703764214798f,
        0.704240755149f,
        0.704717618179f,
        0.705194804109f,
        0.705672313155f,
        0.706150145538f,
        0.706628301475f,
        0.707106781187f,
        0.707585584891f,
        0.708064712809f,
        0.708544165159f,
        0.70902394216f,
        0.709504044034f,
        0.709984470999f,
        0.710465223276f,
        0.710946301085f,
        0.711427704646f,
        0.711909434181f,
        0.712391489909f,
        0.712873872053f,
        0.713356580832f,
        0.713839616468f,
        0.714322979182f,
        0.714806669196f,
        0.715290686731f,
        0.71577503201f,
        0.716259705253f,
        0.716744706684f,
        0.717230036524f,
        0.717715694996f,
        0.718201682322f,
        0.718687998724f,
        0.719174644427f,
        0.719661619653f,
        0.720148924624f,
        0.720636559564f,
        0.721124524697f,
        0.721612820247f,
        0.722101446436f,
        0.722590403489f,
        0.723079691629f,
        0.723569311082f,
        0.724059262071f,
        0.724549544821f,
        0.725040159556f,
        0.725531106502f,
        0.726022385883f,
        0.726513997925f,
        0.727005942851f,
        0.727498220889f,
        0.727990832264f,
        0.728483777201f,
        0.728977055926f,
        0.729470668665f,
        0.729964615644f,
        0.73045889709f,
        0.73095351323f,
        0.731448464289f,
        0.731943750494f,
        0.732439372073f,
        0.732935329253f,
        0.73343162226f,
        0.733928251323f,
        0.734425216668f,
        0.734922518524f,
        0.735420157119f,
        0.735918132679f,
        0.736416445435f,
        0.736915095613f,
        0.737414083442f,
        0.737913409152f,
        0.73841307297f,
        0.738913075126f,
        0.739413415848f,
        0.739914095367f,
        0.740415113911f,
        0.74091647171f,
        0.741418168994f,
        0.741920205993f,
        0.742422582936f,
        0.742925300055f,
        0.743428357578f,
        0.743931755737f,
        0.744435494762f,
        0.744939574885f,
        0.745443996335f,
        0.745948759345f,
        0.746453864146f,
        0.746959310968f,
        0.747465100044f,
        0.747971231605f,
        0.748477705884f,
        0.748984523111f,
        0.749491683521f,
        0.749999187344f,
        0.750507034813f,
        0.751015226162f,
        0.751523761622f,
        0.752032641428f,
        0.752541865812f,
        0.753051435007f,
        0.753561349247f,
        0.754071608766f,
        0.754582213797f,
        0.755093164574f,
        0.755604461332f,
        0.756116104305f,
        0.756628093726f,
        0.757140429832f,
        0.757653112856f,
        0.758166143033f,
        0.758679520599f,
        0.759193245789f,
        0.759707318837f,
        0.760221739981f,
        0.760736509454f,
        0.761251627494f,
        0.761767094336f,
        0.762282910217f,
        0.762799075372f,
        0.763315590039f,
        0.763832454453f,
        0.764349668853f,
        0.764867233474f,
        0.765385148554f,
        0.76590341433f,
        0.766422031039f,
        0.76694099892f,
        0.767460318211f,
        0.767979989148f,
        0.76850001197f,
        0.769020386916f,
        0.769541114223f,
        0.770062194131f,
        0.770583626879f,
        0.771105412704f,
        0.771627551847f,
        0.772150044545f,
        0.77267289104f,
        0.773196091571f,
        0.773719646376f,
        0.774243555696f,
        0.774767819772f,
        0.775292438842f,
        0.775817413149f,
        0.776342742932f,
        0.776868428431f,
        0.777394469889f,
        0.777920867545f,
        0.778447621641f,
        0.778974732418f,
        0.779502200119f,
        0.780030024984f,
        0.780558207255f,
        0.781086747175f,
        0.781615644986f,
        0.782144900929f,
        0.782674515248f,
        0.783204488185f,
        0.783734819983f,
        0.784265510885f,
        0.784796561134f,
        0.785327970973f,
        0.785859740646f,
        0.786391870397f,
        0.786924360469f,
        0.787457211107f,
        0.787990422554f,
        0.788523995055f,
        0.789057928854f,
        0.789592224196f,
        0.790126881326f,
        0.790661900489f,
        0.79119728193f,
        0.791733025894f,
        0.792269132626f,
        0.792805602373f,
        0.79334243538f,
        0.793879631893f,
        0.794417192159f,
        0.794955116422f,
        0.795493404931f,
        0.796032057932f,
        0.796571075671f,
        0.797110458396f,
        0.797650206353f,
        0.79819031979f,
        0.798730798954f,
        0.799271644094f,
        0.799812855456f,
        0.800354433289f,
        0.800896377841f,
        0.801438689361f,
        0.801981368096f,
        0.802524414296f,
        0.803067828208f,
        0.803611610083f,
        0.80415576017f,
        0.804700278717f,
        0.805245165975f,
        0.805790422192f,
        0.806336047619f,
        0.806882042506f,
        0.807428407102f,
        0.807975141659f,
        0.808522246427f,
        0.809069721656f,
        0.809617567597f,
        0.810165784502f,
        0.810714372621f,
        0.811263332206f,
        0.811812663509f,
        0.81236236678f,
        0.812912442273f,
        0.813462890238f,
        0.814013710929f,
        0.814564904597f,
        0.815116471495f,
        0.815668411877f,
        0.816220725994f,
        0.8167734141f,
        0.817326476447f,
        0.817879913291f,
        0.818433724883f,
        0.818987911479f,
        0.819542473331f,
        0.820097410694f,
        0.820652723822f,
        0.82120841297f,
        0.821764478391f,
        0.822320920342f,
        0.822877739077f,
        0.823434934851f,
        0.823992507919f,
        0.824550458537f,
        0.82510878696f,
        0.825667493445f,
        0.826226578247f,
        0.826786041623f,
        0.827345883828f,
        0.82790610512f,
        0.828466705755f,
        0.829027685989f,
        0.829589046081f,
        0.830150786287f,
        0.830712906864f,
        0.83127540807f,
        0.831838290163f,
        0.832401553401f,
        0.832965198042f,
        0.833529224344f,
        0.834093632565f,
        0.834658422965f,
        0.835223595801f,
        0.835789151333f,
        0.836355089821f,
        0.836921411522f,
        0.837488116698f,
        0.838055205607f,
        0.838622678509f,
        0.839190535664f,
        0.839758777333f,
        0.840327403776f,
        0.840896415254f,
        0.841465812026f,
        0.842035594355f,
        0.8426057625f,
        0.843176316724f,
        0.843747257288f,
        0.844318584453f,
        0.844890298481f,
        0.845462399635f,
        0.846034888175f,
        0.846607764365f,
        0.847181028468f,
        0.847754680745f,
        0.848328721459f,
        0.848903150874f,
        0.849477969253f,
        0.850053176859f,
        0.850628773956f,
        0.851204760807f,
        0.851781137677f,
        0.852357904829f,
        0.852935062528f,
        0.853512611038f,
        0.854090550624f,
        0.85466888155f,
        0.855247604082f,
        0.855826718485f,
        0.856406225024f,
        0.856986123965f,
        0.857566415573f,
        0.858147100114f,
        0.858728177855f,
        0.859309649061f,
        0.859891513999f,
        0.860473772936f,
        0.861056426139f,
        0.861639473873f,
        0.862222916407f,
        0.862806754008f,
        0.863390986944f,
        0.863975615481f,
        0.864560639888f,
        0.865146060434f,
        0.865731877385f,
        0.866318091011f,
        0.866904701581f,
        0.867491709362f,
        0.868079114624f,
        0.868666917637f,
        0.869255118669f,
        0.86984371799f,
        0.870432715869f,
        0.871022112578f,
        0.871611908384f,
        0.87220210356f,
        0.872792698375f,
        0.8733836931f,
        0.873975088005f,
        0.874566883362f,
        0.875159079442f,
        0.875751676516f,
        0.876344674856f,
        0.876938074733f,
        0.877531876419f,
        0.878126080187f,
        0.878720686308f,
        0.879315695055f,
        0.879911106701f,
        0.880506921519f,
        0.881103139781f,
        0.881699761761f,
        0.882296787731f,
        0.882894217967f,
        0.88349205274f,
        0.884090292326f,
        0.884688936999f,
        0.885287987032f,
        0.8858874427f,
        0.886487304278f,
        0.887087572041f,
        0.887688246263f,
        0.888289327221f,
        0.888890815188f,
        0.889492710442f,
        0.890095013258f,
        0.890697723911f,
        0.891300842678f,
        0.891904369835f,
        0.892508305659f,
        0.893112650427f,
        0.893717404415f,
        0.8943225679f,
        0.894928141161f,
        0.895534124473f,
        0.896140518116f,
        0.896747322366f,
        0.897354537502f,
        0.897962163801f,
        0.898570201544f,
        0.899178651007f,
        0.89978751247f,
        0.900396786212f,
        0.901006472512f,
        0.901616571649f,
        0.902227083903f,
        0.902838009554f,
        0.903449348881f,
        0.904061102165f,
        0.904673269686f,
        0.905285851724f,
        0.90589884856f,
        0.906512260475f,
        0.90712608775f,
        0.907740330667f,
        0.908354989506f,
        0.90897006455f,
        0.909585556079f,
        0.910201464377f,
        0.910817789726f,
        0.911434532407f,
        0.912051692704f,
        0.912669270898f,
        0.913287267274f,
        0.913905682115f,
        0.914524515702f,
        0.915143768322f,
        0.915763440256f,
        0.916383531789f,
        0.917004043205f,
        0.917624974788f,
        0.918246326823f,
        0.918868099595f,
        0.919490293388f,
        0.920112908488f,
        0.920735945179f,
        0.921359403748f,
        0.921983284479f,
        0.92260758766f,
        0.923232313575f,
        0.923857462511f,
        0.924483034755f,
        0.925109030593f,
        0.925735450312f,
        0.926362294199f,
        0.926989562542f,
        0.927617255627f,
        0.928245373742f,
        0.928873917175f,
        0.929502886214f,
        0.930132281148f,
        0.930762102264f,
        0.931392349852f,
        0.932023024199f,
        0.932654125595f,
        0.93328565433f,
        0.933917610692f,
        0.934549994971f,
        0.935182807456f,
        0.935816048439f,
        0.936449718208f,
        0.937083817055f,
        0.93771834527f,
        0.938353303143f,
        0.938988690965f,
        0.939624509028f,
        0.940260757623f,
        0.940897437042f,
        0.941534547575f,
        0.942172089516f,
        0.942810063156f,
        0.943448468788f,
        0.944087306703f,
        0.944726577195f,
        0.945366280557f,
        0.946006417082f,
        0.946646987063f,
        0.947287990793f,
        0.947929428567f,
        0.948571300678f,
        0.94921360742f,
        0.949856349088f,
        0.950499525976f,
        0.951143138379f,
        0.951787186592f,
        0.952431670909f,
        0.953076591626f,
        0.953721949039f,
        0.954367743444f,
        0.955013975135f,
        0.95566064441f,
        0.956307751565f,
        0.956955296895f,
        0.957603280699f,
        0.958251703272f,
        0.958900564912f,
        0.959549865916f,
        0.960199606582f,
        0.960849787207f,
        0.961500408089f,
        0.962151469527f,
        0.962802971818f,
        0.963454915262f,
        0.964107300156f,
        0.964760126801f,
        0.965413395494f,
        0.966067106535f,
        0.966721260225f,
        0.967375856862f,
        0.968030896746f,
        0.968686380178f,
        0.969342307458f,
        0.969998678887f,
        0.970655494764f,
        0.971312755392f,
        0.971970461071f,
        0.972628612103f,
        0.97328720879f,
        0.973946251432f,
        0.974605740332f,
        0.975265675793f,
        0.975926058115f,
        0.976586887604f,
        0.97724816456f,
        0.977909889287f,
        0.978572062088f,
        0.979234683266f,
        0.979897753126f,
        0.980561271971f,
        0.981225240104f,
        0.981889657831f,
        0.982554525456f,
        0.983219843283f,
        0.983885611617f,
        0.984551830763f,
        0.985218501026f,
        0.985885622713f,
        0.986553196128f,
        0.987221221577f,
        0.987889699367f,
        0.988558629804f,
        0.989228013194f,
        0.989897849844f,
        0.990568140061f,
        0.991238884152f,
        0.991910082425f,
        0.992581735187f,
        0.993253842745f,
        0.993926405408f,
        0.994599423484f,
        0.995272897281f,
        0.995946827107f,
        0.996621213273f,
        0.997296056085f,
        0.997971355855f,
        0.998647112891f,
        0.999323327503f,
        1.0f,
        1.00067713069f,
        1.00135471989f,
        1.00203276791f,
        1.00271127505f,
        1.00339024163f,
        1.00406966796f,
        1.00474955435f,
        1.00542990111f,
        1.00611070856f,
        1.006791977f,
        1.00747370675f,
        1.00815589812f,
        1.00883855142f,
        1.00952166697f,
        1.01020524507f,
        1.01088928605f,
        1.01157379021f,
        1.01225875788f,
        1.01294418935f,
        1.01363008495f,
        1.01431644499f,
        1.01500326979f,
        1.01569055966f,
        1.01637831491f,
        1.01706653586f,
        1.01775522283f,
        1.01844437613f,
        1.01913399608f,
        1.01982408299f,
        1.02051463717f,
        1.02120565896f,
        1.02189714865f,
        1.02258910658f,
        1.02328153305f,
        1.02397442838f,
        1.0246677929f,
        1.02536162691f,
        1.02605593074f,
        1.0267507047f,
        1.02744594912f,
        1.02814166431f,
        1.02883785058f,
        1.02953450827f,
        1.03023163769f,
        1.03092923915f,
        1.03162731298f,
        1.0323258595f,
        1.03302487902f,
        1.03372437187f,
        1.03442433837f,
        1.03512477884f,
        1.0358256936f,
        1.03652708297f,
        1.03722894727f,
        1.03793128683f,
        1.03863410196f,
        1.03933739299f,
        1.04004116024f,
        1.04074540403f,
        1.04145012469f,
        1.04215532253f,
        1.04286099789f,
        1.04356715108f,
        1.04427378243f,
        1.04498089226f,
        1.04568848089f,
        1.04639654866f,
        1.04710509588f,
        1.04781412288f,
        1.04852362998f,
        1.04923361751f,
        1.0499440858f,
        1.05065503517f,
        1.05136646594f,
        1.05207837844f,
        1.052790773f,
        1.05350364995f,
        1.05421700961f,
        1.0549308523f,
        1.05564517836f,
        1.05635998811f,
        1.05707528188f,
        1.05779106f,
        1.05850732279f,
        1.05922407059f,
        1.05994130372f,
        1.06065902251f,
        1.06137722729f,
        1.06209591839f,
        1.06281509613f,
        1.06353476085f,
        1.06425491288f,
        1.06497555255f,
        1.06569668019f,
        1.06641829612f,
        1.06714040068f,
        1.0678629942f,
        1.06858607701f,
        1.06930964944f,
        1.07003371182f,
        1.07075826449f,
        1.07148330777f,
        1.07220884201f,
        1.07293486753f,
        1.07366138466f,
        1.07438839373f,
        1.07511589509f,
        1.07584388906f,
        1.07657237598f,
        1.07730135618f,
        1.07803082999f,
        1.07876079776f,
        1.0794912598f,
        1.08022221647f,
        1.08095366809f,
        1.08168561499f,
        1.08241805752f,
        1.08315099601f,
        1.0838844308f,
        1.08461836221f,
        1.0853527906f,
        1.08608771628f,
        1.08682313961f,
        1.08755906092f,
        1.08829548054f,
        1.08903239881f,
        1.08976981607f,
        1.09050773267f,
        1.09124614892f,
        1.09198506518f,
        1.09272448179f,
        1.09346439907f,
        1.09420481738f,
        1.09494573705f,
        1.09568715841f,
        1.09642908182f,
        1.0971715076f,
        1.0979144361f,
        1.09865786767f,
        1.09940180263f,
        1.10014624133f,
        1.10089118412f,
        1.10163663133f,
        1.10238258331f,
        1.10312904039f,
        1.10387600292f,
        1.10462347125f,
        1.1053714457f,
        1.10611992663f,
        1.10686891439f,
        1.1076184093f,
        1.10836841172f,
        1.10911892199f,
        1.10986994046f,
        1.11062146746f,
        1.11137350334f,
        1.11212604846f,
        1.11287910314f,
        1.11363266774f,
        1.1143867426f,
        1.11514132806f,
        1.11589642448f,
        1.1166520322f,
        1.11740815157f,
        1.11816478292f,
        1.11892192662f,
        1.119679583f,
        1.12043775241f,
        1.1211964352f,
        1.12195563172f,
        1.12271534232f,
        1.12347556733f,
        1.12423630712f,
        1.12499756203f,
        1.12575933241f,
        1.12652161861f,
        1.12728442097f,
        1.12804773985f,
        1.1288115756f,
        1.12957592857f,
        1.1303407991f,
        1.13110618755f,
        1.13187209426f,
        1.1326385196f,
        1.1334054639f,
        1.13417292753f,
        1.13494091083f,
        1.13570941416f,
        1.13647843786f,
        1.13724798229f,
        1.13801804781f,
        1.13878863476f,
        1.13955974349f,
        1.14033137437f,
        1.14110352775f,
        1.14187620397f,
        1.14264940339f,
        1.14342312638f,
        1.14419737327f,
        1.14497214443f,
        1.14574744021f,
        1.14652326097f,
        1.14729960706f,
        1.14807647884f,
        1.14885387666f,
        1.14963180088f,
        1.15041025186f,
        1.15118922995f,
        1.15196873551f,
        1.1527487689f,
        1.15352933048f,
        1.15431042059f,
        1.15509203961f,
        1.15587418788f,
        1.15665686577f,
        1.15744007363f,
        1.15822381183f,
        1.15900808073f,
        1.15979288067f,
        1.16057821203f,
        1.16136407516f,
        1.16215047042f,
        1.16293739817f,
        1.16372485878f,
        1.1645128526f,
        1.16530137999f,
        1.16609044132f,
        1.16688003695f,
        1.16767016724f,
        1.16846083255f,
        1.16925203324f,
        1.17004376968f,
        1.17083604223f,
        1.17162885125f,
        1.17242219711f,
        1.17321608016f,
        1.17401050078f,
        1.17480545933f,
        1.17560095616f,
        1.17639699165f,
        1.17719356616f,
        1.17799068006f,
        1.1787883337f,
        1.17958652746f,
        1.18038526171f,
        1.1811845368f,
        1.1819843531f,
        1.18278471098f,
        1.18358561082f,
        1.18438705296f,
        1.18518903779f,
        1.18599156566f,
        1.18679463695f,
        1.18759825203f,
        1.18840241125f,
        1.189207115f,
        1.19001236364f,
        1.19081815754f,
        1.19162449706f,
        1.19243138258f,
        1.19323881447f,
        1.1940467931f,
        1.19485531883f,
        1.19566439204f,
        1.1964740131f,
        1.19728418238f,
        1.19809490024f,
        1.19890616707f,
        1.19971798324f,
        1.20053034911f,
        1.20134326506f,
        1.20215673145f,
        1.20297074867f,
        1.20378531709f,
        1.20460043708f,
        1.20541610901f,
        1.20623233325f,
        1.20704911019f,
        1.20786644019f,
        1.20868432363f,
        1.20950276088f,
        1.21032175232f,
        1.21114129833f,
        1.21196139928f,
        1.21278205554f,
        1.21360326749f,
        1.21442503551f,
        1.21524735998f,
        1.21607024127f,
        1.21689367975f,
        1.21771767581f,
        1.21854222983f,
        1.21936734217f,
        1.22019301323f,
        1.22101924337f,
        1.22184603297f,
        1.22267338242f,
        1.2235012921f,
        1.22432976238f,
        1.22515879364f,
        1.22598838626f,
        1.22681854063f,
        1.22764925711f,
        1.22848053611f,
        1.22931237798f,
        1.23014478313f,
        1.23097775192f,
        1.23181128473f,
        1.23264538196f,
        1.23348004398f,
        1.23431527118f,
        1.23515106394f,
        1.23598742263f,
        1.23682434765f,
        1.23766183938f,
        1.2384998982f,
        1.23933852449f,
        1.24017771865f,
        1.24101748105f,
        1.24185781207f,
        1.24269871211f,
        1.24354018155f,
        1.24438222078f,
        1.24522483018f,
        1.24606801013f,
        1.24691176102f,
        1.24775608325f,
        1.24860097719f,
        1.24944644323f,
        1.25029248177f,
        1.25113909319f,
        1.25198627787f,
        1.2528340362f,
        1.25368236858f,
        1.25453127539f,
        1.25538075702f,
        1.25623081387f,
        1.25708144631f,
        1.25793265474f,
        1.25878443955f,
        1.25963680113f,
        1.26048973987f,
        1.26134325616f,
        1.26219735039f,
        1.26305202296f,
        1.26390727425f,
        1.26476310466f,
        1.26561951458f,
        1.2664765044f,
        1.26733407451f,
        1.26819222531f,
        1.26905095719f,
        1.26991027055f,
        1.27077016577f,
        1.27163064325f,
        1.27249170339f,
        1.27335334658f,
        1.27421557321f,
        1.27507838369f,
        1.2759417784f,
        1.27680575774f,
        1.2776703221f,
        1.2785354719f,
        1.27940120751f,
        1.28026752933f,
        1.28113443777f,
        1.28200193322f,
        1.28287001608f,
        1.28373868674f,
        1.28460794561f,
        1.28547779308f,
        1.28634822955f,
        1.28721925541f,
        1.28809087108f,
        1.28896307695f,
        1.28983587341f,
        1.29070926087f,
        1.29158323972f,
        1.29245781038f,
        1.29333297323f,
        1.29420872868f,
        1.29508507714f,
        1.29596201899f,
        1.29683955465f,
        1.29771768452f,
        1.29859640899f,
        1.29947572848f,
        1.30035564338f,
        1.3012361541f,
        1.30211726104f,
        1.3029989646f,
        1.30388126519f,
        1.30476416322f,
        1.30564765908f,
        1.30653175318f,
        1.30741644593f,
        1.30830173774f,
        1.309187629f,
        1.31007412013f,
        1.31096121152f,
        1.3118489036f,
        1.31273719676f,
        1.3136260914f,
        1.31451558795f,
        1.3154056868f,
        1.31629638836f,
        1.31718769305f,
        1.31807960127f,
        1.31897211342f,
        1.31986522992f,
        1.32075895118f,
        1.3216532776f,
        1.3225482096f,
        1.32344374759f,
        1.32433989197f,
        1.32523664316f,
        1.32613400157f,
        1.3270319676f,
        1.32793054168f,
        1.32882972421f,
        1.3297295156f,
        1.33062991627f,
        1.33153092662f,
        1.33243254708f,
        1.33333477806f,
        1.33423761996f,
        1.3351410732f,
        1.3360451382f,
        1.33694981537f,
        1.33785510513f,
        1.33876100788f,
        1.33966752405f,
        1.34057465405f,
        1.3414823983f,
        1.3423907572f,
        1.34329973119f,
        1.34420932066f,
        1.34511952605f,
        1.34603034777f,
        1.34694178623f,
        1.34785384186f,
        1.34876651506f,
        1.34967980627f,
        1.35059371589f,
        1.35150824435f,
        1.35242339207f,
        1.35333915945f,
        1.35425554694f,
        1.35517255493f,
        1.35609018387f,
        1.35700843415f,
        1.35792730621f,
        1.35884680047f,
        1.35976691735f,
        1.36068765726f,
        1.36160902064f,
        1.3625310079f,
        1.36345361946f,
        1.36437685576f,
        1.3653007172f,
        1.36622520422f,
        1.36715031724f,
        1.36807605669f,
        1.36900242297f,
        1.36992941653f,
        1.37085703779f,
        1.37178528717f,
        1.37271416509f,
        1.37364367198f,
        1.37457380827f,
        1.37550457439f,
        1.37643597075f,
        1.3773679978f,
        1.37830065594f,
        1.37923394562f,
        1.38016786726f,
        1.38110242128f,
        1.38203760812f,
        1.38297342821f,
        1.38390988196f,
        1.38484696982f,
        1.38578469221f,
        1.38672304956f,
        1.3876620423f,
        1.38860167086f,
        1.38954193567f,
        1.39048283716f,
        1.39142437577f,
        1.39236655192f,
        1.39330936605f,
        1.39425281859f,
        1.39519690997f,
        1.39614164062f,
        1.39708701097f,
        1.39803302147f,
        1.39897967254f,
        1.39992696461f,
        1.40087489813f,
        1.40182347352f,
        1.40277269122f,
        1.40372255166f,
        1.40467305529f,
        1.40562420253f,
        1.40657599382f,
        1.4075284296f,
        1.4084815103f,
        1.40943523636f,
        1.41038960822f,
        1.41134462631f,
        1.41230029108f,
        1.41325660295f,
        1.41421356237f,
        1.41517116978f,
        1.41612942562f,
        1.41708833032f,
        1.41804788432f,
        1.41900808807f,
        1.419968942f,
        1.42093044655f,
        1.42189260217f,
        1.42285540929f,
        1.42381886836f,
        1.42478297982f,
        1.42574774411f,
        1.42671316166f,
        1.42767923294f,
        1.42864595836f,
        1.42961333839f,
        1.43058137346f,
        1.43155006402f,
        1.43251941051f,
        1.43348941337f,
        1.43446007305f,
        1.43543138999f,
        1.43640336464f,
        1.43737599745f,
        1.43834928885f,
        1.43932323931f,
        1.44029784925f,
        1.44127311913f,
        1.44224904939f,
        1.44322564049f,
        1.44420289287f,
        1.44518080698f,
        1.44615938326f,
        1.44713862216f,
        1.44811852414f,
        1.44909908964f,
        1.45008031911f,
        1.451062213f,
        1.45204477177f,
        1.45302799585f,
        1.4540118857f,
        1.45499644178f,
        1.45598166453f,
        1.4569675544f,
        1.45795411185f,
        1.45894133733f,
        1.45992923129f,
        1.46091779418f,
        1.46190702646f,
        1.46289692858f,
        1.46388750099f,
        1.46487874415f,
        1.46587065851f,
        1.46686324452f,
        1.46785650265f,
        1.46885043334f,
        1.46984503705f,
        1.47084031424f,
        1.47183626536f,
        1.47283289087f,
        1.47383019123f,
        1.47482816688f,
        1.4758268183f,
        1.47682614594f,
        1.47782615025f,
        1.4788268317f,
        1.47982819073f,
        1.48083022782f,
        1.48183294342f,
        1.48283633799f,
        1.48384041199f,
        1.48484516587f,
        1.48585060011f,
        1.48685671516f,
        1.48786351147f,
        1.48887098952f,
        1.48987914977f,
        1.49088799267f,
        1.49189751869f,
        1.49290772829f,
        1.49391862194f,
        1.49493020009f,
        1.49594246321f,
        1.49695541177f,
        1.49796904622f,
        1.49898336704f,
        1.49999837469f,
        1.50101406963f,
        1.50203045232f,
        1.50304752324f,
        1.50406528286f,
        1.50508373162f,
        1.50610287001f,
        1.50712269849f,
        1.50814321753f,
        1.50916442759f,
        1.51018632915f,
        1.51120892266f,
        1.51223220861f,
        1.51325618745f,
        1.51428085966f,
        1.51530622571f,
        1.51633228607f,
        1.5173590412f,
        1.51838649158f,
        1.51941463767f,
        1.52044347996f,
        1.52147301891f,
        1.52250325499f,
        1.52353418867f,
        1.52456582043f,
        1.52559815074f,
        1.52663118008f,
        1.52766490891f,
        1.52869933771f,
        1.52973446695f,
        1.53077029711f,
        1.53180682866f,
        1.53284406208f,
        1.53388199784f,
        1.53492063642f,
        1.5359599783f,
        1.53700002394f,
        1.53804077383f,
        1.53908222845f,
        1.54012438826f,
        1.54116725376f,
        1.54221082541f,
        1.54325510369f,
        1.54430008909f,
        1.54534578208f,
        1.54639218314f,
        1.54743929275f,
        1.54848711139f,
        1.54953563954f,
        1.55058487768f,
        1.5516348263f,
        1.55268548586f,
        1.55373685686f,
        1.55478893978f,
        1.55584173509f,
        1.55689524328f,
        1.55794946484f,
        1.55900440024f,
        1.56006004997f,
        1.56111641451f,
        1.56217349435f,
        1.56323128997f,
        1.56428980186f,
        1.5653490305f,
        1.56640897637f,
        1.56746963997f,
        1.56853102177f,
        1.56959312227f,
        1.57065594195f,
        1.57171948129f,
        1.57278374079f,
        1.57384872094f,
        1.57491442221f,
        1.57598084511f,
        1.57704799011f,
        1.57811585771f,
        1.57918444839f,
        1.58025376265f,
        1.58132380098f,
        1.58239456386f,
        1.58346605179f,
        1.58453826525f,
        1.58561120475f,
        1.58668487076f,
        1.58775926379f,
        1.58883438432f,
        1.58991023284f,
        1.59098680986f,
        1.59206411586f,
        1.59314215134f,
        1.59422091679f,
        1.59530041271f,
        1.59638063958f,
        1.59746159791f,
        1.59854328819f,
        1.59962571091f,
        1.60070886658f,
        1.60179275568f,
        1.60287737872f,
        1.60396273619f,
        1.60504882859f,
        1.60613565642f,
        1.60722322017f,
        1.60831152034f,
        1.60940055743f,
        1.61049033195f,
        1.61158084438f,
        1.61267209524f,
        1.61376408501f,
        1.6148568142f,
        1.61595028332f,
        1.61704449285f,
        1.61813944331f,
        1.61923513519f,
        1.620331569f,
        1.62142874524f,
        1.62252666441f,
        1.62362532702f,
        1.62472473356f,
        1.62582488455f,
        1.62692578048f,
        1.62802742186f,
        1.62912980919f,
        1.63023294299f,
        1.63133682375f,
        1.63244145199f,
        1.6335468282f,
        1.63465295289f,
        1.63575982658f,
        1.63686744977f,
        1.63797582296f,
        1.63908494666f,
        1.64019482139f,
        1.64130544764f,
        1.64241682594f,
        1.64352895678f,
        1.64464184068f,
        1.64575547815f,
        1.6468698697f,
        1.64798501584f,
        1.64910091707f,
        1.65021757392f,
        1.65133498689f,
        1.65245315649f,
        1.65357208325f,
        1.65469176766f,
        1.65581221024f,
        1.65693341151f,
        1.65805537198f,
        1.65917809216f,
        1.66030157257f,
        1.66142581373f,
        1.66255081614f,
        1.66367658033f,
        1.6648031068f,
        1.66593039608f,
        1.66705844869f,
        1.66818726513f,
        1.66931684593f,
        1.6704471916f,
        1.67157830267f,
        1.67271017964f,
        1.67384282304f,
        1.6749762334f,
        1.67611041121f,
        1.67724535702f,
        1.67838107133f,
        1.67951755467f,
        1.68065480755f,
        1.68179283051f,
        1.68293162405f,
        1.68407118871f,
        1.685211525f,
        1.68635263345f,
        1.68749451458f,
        1.68863716891f,
        1.68978059696f,
        1.69092479927f,
        1.69206977635f,
        1.69321552873f,
        1.69436205694f,
        1.69550936149f,
        1.69665744292f,
        1.69780630175f,
        1.69895593851f,
        1.70010635372f,
        1.70125754791f,
        1.70240952161f,
        1.70356227535f,
        1.70471580966f,
        1.70587012506f,
        1.70702522208f,
        1.70818110125f,
        1.7093377631f,
        1.71049520816f,
        1.71165343697f,
        1.71281245005f,
        1.71397224793f,
        1.71513283115f,
        1.71629420023f,
        1.71745635571f,
        1.71861929812f,
        1.719783028f,
        1.72094754587f,
        1.72211285228f,
        1.72327894775f,
        1.72444583281f,
        1.72561350802f,
        1.72678197389f,
        1.72795123096f,
        1.72912127978f,
        1.73029212087f,
        1.73146375477f,
        1.73263618202f,
        1.73380940316f,
        1.73498341872f,
        1.73615822925f,
        1.73733383527f,
        1.73851023734f,
        1.73968743598f,
        1.74086543174f,
        1.74204422516f,
        1.74322381677f,
        1.74440420712f,
        1.74558539675f,
        1.7467673862f,
        1.74795017601f,
        1.74913376672f,
        1.75031815888f,
        1.75150335303f,
        1.75268934971f,
        1.75387614947f,
        1.75506375284f,
        1.75625216037f,
        1.75744137262f,
        1.75863139011f,
        1.7598222134f,
        1.76101384304f,
        1.76220627956f,
        1.76339952352f,
        1.76459357546f,
        1.76578843593f,
        1.76698410548f,
        1.76818058465f,
        1.769377874f,
        1.77057597406f,
        1.7717748854f,
        1.77297460856f,
        1.77417514408f,
        1.77537649253f,
        1.77657865444f,
        1.77778163038f,
        1.77898542088f,
        1.78019002652f,
        1.78139544782f,
        1.78260168536f,
        1.78380873967f,
        1.78501661132f,
        1.78622530085f,
        1.78743480883f,
        1.7886451358f,
        1.78985628232f,
        1.79106824895f,
        1.79228103623f,
        1.79349464473f,
        1.794709075f,
        1.7959243276f,
        1.79714040309f,
        1.79835730201f,
        1.79957502494f,
        1.80079357242f,
        1.80201294502f,
        1.8032331433f,
        1.80445416781f,
        1.80567601911f,
        1.80689869776f,
        1.80812220433f,
        1.80934653937f,
        1.81057170345f,
        1.81179769712f,
        1.81302452095f,
        1.8142521755f,
        1.81548066133f,
        1.81670997901f,
        1.8179401291f,
        1.81917111216f,
        1.82040292875f,
        1.82163557945f,
        1.82286906481f,
        1.82410338541f,
        1.8253385418f,
        1.82657453455f,
        1.82781136423f,
        1.8290490314f,
        1.83028753664f,
        1.83152688051f,
        1.83276706358f,
        1.83400808641f,
        1.83524994958f,
        1.83649265365f,
        1.83773619919f,
        1.83898058678f,
        1.84022581698f,
        1.84147189036f,
        1.8427188075f,
        1.84396656896f,
        1.84521517532f,
        1.84646462715f,
        1.84771492502f,
        1.84896606951f,
        1.85021806119f,
        1.85147090062f,
        1.8527245884f,
        1.85397912508f,
        1.85523451125f,
        1.85649074748f,
        1.85774783435f,
        1.85900577243f,
        1.8602645623f,
        1.86152420453f,
        1.8627846997f,
        1.8640460484f,
        1.86530825119f,
        1.86657130866f,
        1.86783522138f,
        1.86909998994f,
        1.87036561491f,
        1.87163209688f,
        1.87289943642f,
        1.87416763411f,
        1.87543669054f,
        1.87670660629f,
        1.87797738193f,
        1.87924901806f,
        1.88052151525f,
        1.88179487408f,
        1.88306909515f,
        1.88434417903f,
        1.88562012631f,
        1.88689693758f,
        1.88817461341f,
        1.88945315439f,
        1.89073256111f,
        1.89201283416f,
        1.89329397413f,
        1.89457598159f,
        1.89585885713f,
        1.89714260136f,
        1.89842721484f,
        1.89971269818f,
        1.90099905195f,
        1.90228627676f,
        1.90357437318f,
        1.90486334182f,
        1.90615318325f,
        1.90744389808f,
        1.90873548689f,
        1.91002795027f,
        1.91132128882f,
        1.91261550313f,
        1.91391059379f,
        1.9152065614f,
        1.91650340654f,
        1.91780112982f,
        1.91909973183f,
        1.92039921316f,
        1.92169957441f,
        1.92300081618f,
        1.92430293905f,
        1.92560594364f,
        1.92690983052f,
        1.92821460031f,
        1.9295202536f,
        1.93082679099f,
        1.93213421307f,
        1.93344252045f,
        1.93475171372f,
        1.93606179349f,
        1.93737276036f,
        1.93868461492f,
        1.93999735777f,
        1.94131098953f,
        1.94262551078f,
        1.94394092214f,
        1.94525722421f,
        1.94657441758f,
        1.94789250286f,
        1.94921148066f,
        1.95053135159f,
        1.95185211623f,
        1.95317377521f,
        1.95449632912f,
        1.95581977857f,
        1.95714412418f,
        1.95846936653f,
        1.95979550625f,
        1.96112254394f,
        1.96245048021f,
        1.96377931566f,
        1.96510905091f,
        1.96643968657f,
        1.96777122323f,
        1.96910366153f,
        1.97043700205f,
        1.97177124543f,
        1.97310639226f,
        1.97444244315f,
        1.97577939873f,
        1.97711725961f,
        1.97845602639f,
        1.97979569969f,
        1.98113628012f,
        1.9824777683f,
        1.98382016485f,
        1.98516347037f,
        1.98650768549f,
        1.98785281082f,
        1.98919884697f,
        1.99054579456f,
        1.99189365421f,
        1.99324242655f,
        1.99459211217f,
        1.99594271171f,
        1.99729422578f,
        1.99864665501f,
    };
    static_assert(ARRAY_COUNT(exp2_table) == 1023+1+1023, "");
    static_assert(exp2_table[1023] == 1.0f, "");

    // 2^x
    //   == 2^(int(x) + fract(x))
    //   == 2^(int(x)) * 2^(fract(x))

    I32 int_x = cast<I32>(x);
    F fract_x = x - cast<F>(int_x);

    // We'll look up the fractional part in our table,
    // taking care for x = -inf, which happens in calls to approx_pow(0,g).
    // Our result will be ignored; we just can't underflow the table.
    I32 ix = cast<I32>(fract_x * 1024) + 1023;
    ix = if_then_else(ix < 0, I32(0), ix);

    // The integer side of things is easier: to make 2^int(x), just jam it into the exponent.
    return bit_pun<F>( (int_x + 127) << 23 )
         * (F)_mm512_i32gather_ps(ix, exp2_table, 4);
#else
    F fract = x - floor_(x);

    I32 bits = cast<I32>((1.0f * (1<<23)) * (x + 121.274057500f
                                               -   1.490129070f*fract
                                               +  27.728023300f/(4.84252568f - fract)));
    return bit_pun<F>(bits);
#endif
}

SI F approx_pow(F x, float y) {
    return if_then_else((x == F0) | (x == F1), x
                                             , approx_exp2(approx_log2(x) * y));
}

// Return tf(x).
SI F apply_tf(const skcms_TransferFunction* tf, F x) {
#if defined(USING_NEON_FP16)
    // TODO(mtklein)
    (void)tf;
    return x;
#else
    // Peel off the sign bit and set x = |x|.
    U32 bits = bit_pun<U32>(x),
        sign = bits & 0x80000000;
    x = bit_pun<F>(bits ^ sign);

    // The transfer function has a linear part up to d, exponential at d and after.
    F v = if_then_else(x < tf->d,            tf->c*x + tf->f
                                , approx_pow(tf->a*x + tf->b, tf->g) + tf->e);

    // Tack the sign bit back on.
    return bit_pun<F>(sign | bit_pun<U32>(v));
#endif
}


// Strided loads and stores of N values, starting from p.
template <typename T, typename P>
SI T load_3(const P* p) {
#if N == 1
    return (T)p[0];
#elif N == 4
    return T{p[ 0],p[ 3],p[ 6],p[ 9]};
#elif N == 8
    return T{p[ 0],p[ 3],p[ 6],p[ 9], p[12],p[15],p[18],p[21]};
#elif N == 16
    return T{p[ 0],p[ 3],p[ 6],p[ 9], p[12],p[15],p[18],p[21],
             p[24],p[27],p[30],p[33], p[36],p[39],p[42],p[45]};
#endif
}

template <typename T, typename P>
SI T load_4(const P* p) {
#if N == 1
    return (T)p[0];
#elif N == 4
    return T{p[ 0],p[ 4],p[ 8],p[12]};
#elif N == 8
    return T{p[ 0],p[ 4],p[ 8],p[12], p[16],p[20],p[24],p[28]};
#elif N == 16
    return T{p[ 0],p[ 4],p[ 8],p[12], p[16],p[20],p[24],p[28],
             p[32],p[36],p[40],p[44], p[48],p[52],p[56],p[60]};
#endif
}

template <typename T, typename P>
SI void store_3(P* p, const T& v) {
#if N == 1
    p[0] = v;
#elif N == 4
    p[ 0] = v[ 0]; p[ 3] = v[ 1]; p[ 6] = v[ 2]; p[ 9] = v[ 3];
#elif N == 8
    p[ 0] = v[ 0]; p[ 3] = v[ 1]; p[ 6] = v[ 2]; p[ 9] = v[ 3];
    p[12] = v[ 4]; p[15] = v[ 5]; p[18] = v[ 6]; p[21] = v[ 7];
#elif N == 16
    p[ 0] = v[ 0]; p[ 3] = v[ 1]; p[ 6] = v[ 2]; p[ 9] = v[ 3];
    p[12] = v[ 4]; p[15] = v[ 5]; p[18] = v[ 6]; p[21] = v[ 7];
    p[24] = v[ 8]; p[27] = v[ 9]; p[30] = v[10]; p[33] = v[11];
    p[36] = v[12]; p[39] = v[13]; p[42] = v[14]; p[45] = v[15];
#endif
}

template <typename T, typename P>
SI void store_4(P* p, const T& v) {
#if N == 1
    p[0] = v;
#elif N == 4
    p[ 0] = v[ 0]; p[ 4] = v[ 1]; p[ 8] = v[ 2]; p[12] = v[ 3];
#elif N == 8
    p[ 0] = v[ 0]; p[ 4] = v[ 1]; p[ 8] = v[ 2]; p[12] = v[ 3];
    p[16] = v[ 4]; p[20] = v[ 5]; p[24] = v[ 6]; p[28] = v[ 7];
#elif N == 16
    p[ 0] = v[ 0]; p[ 4] = v[ 1]; p[ 8] = v[ 2]; p[12] = v[ 3];
    p[16] = v[ 4]; p[20] = v[ 5]; p[24] = v[ 6]; p[28] = v[ 7];
    p[32] = v[ 8]; p[36] = v[ 9]; p[40] = v[10]; p[44] = v[11];
    p[48] = v[12]; p[52] = v[13]; p[56] = v[14]; p[60] = v[15];
#endif
}


SI U8 gather_8(const uint8_t* p, I32 ix) {
#if N == 1
    U8 v = p[ix];
#elif N == 4
    U8 v = { p[ix[0]], p[ix[1]], p[ix[2]], p[ix[3]] };
#elif N == 8
    U8 v = { p[ix[0]], p[ix[1]], p[ix[2]], p[ix[3]],
             p[ix[4]], p[ix[5]], p[ix[6]], p[ix[7]] };
#elif N == 16
    U8 v = { p[ix[ 0]], p[ix[ 1]], p[ix[ 2]], p[ix[ 3]],
             p[ix[ 4]], p[ix[ 5]], p[ix[ 6]], p[ix[ 7]],
             p[ix[ 8]], p[ix[ 9]], p[ix[10]], p[ix[11]],
             p[ix[12]], p[ix[13]], p[ix[14]], p[ix[15]] };
#endif
    return v;
}

SI U16 gather_16(const uint8_t* p, I32 ix) {
    // Load the i'th 16-bit value from p.
    auto load_16 = [p](int i) {
        return load<uint16_t>(p + 2*i);
    };
#if N == 1
    U16 v = load_16(ix);
#elif N == 4
    U16 v = { load_16(ix[0]), load_16(ix[1]), load_16(ix[2]), load_16(ix[3]) };
#elif N == 8
    U16 v = { load_16(ix[0]), load_16(ix[1]), load_16(ix[2]), load_16(ix[3]),
              load_16(ix[4]), load_16(ix[5]), load_16(ix[6]), load_16(ix[7]) };
#elif N == 16
    U16 v = { load_16(ix[ 0]), load_16(ix[ 1]), load_16(ix[ 2]), load_16(ix[ 3]),
              load_16(ix[ 4]), load_16(ix[ 5]), load_16(ix[ 6]), load_16(ix[ 7]),
              load_16(ix[ 8]), load_16(ix[ 9]), load_16(ix[10]), load_16(ix[11]),
              load_16(ix[12]), load_16(ix[13]), load_16(ix[14]), load_16(ix[15]) };
#endif
    return v;
}

SI U32 gather_32(const uint8_t* p, I32 ix) {
    // Load the i'th 32-bit value from p.
    auto load_32 = [p](int i) {
        return load<uint32_t>(p + 4*i);
    };
#if N == 1
    U32 v = load_32(ix);
#elif N == 4
    U32 v = { load_32(ix[0]), load_32(ix[1]), load_32(ix[2]), load_32(ix[3]) };
#elif N == 8
    U32 v = { load_32(ix[0]), load_32(ix[1]), load_32(ix[2]), load_32(ix[3]),
              load_32(ix[4]), load_32(ix[5]), load_32(ix[6]), load_32(ix[7]) };
#elif N == 16
    U32 v = { load_32(ix[ 0]), load_32(ix[ 1]), load_32(ix[ 2]), load_32(ix[ 3]),
              load_32(ix[ 4]), load_32(ix[ 5]), load_32(ix[ 6]), load_32(ix[ 7]),
              load_32(ix[ 8]), load_32(ix[ 9]), load_32(ix[10]), load_32(ix[11]),
              load_32(ix[12]), load_32(ix[13]), load_32(ix[14]), load_32(ix[15]) };
#endif
    // TODO: AVX2 and AVX-512 gathers (c.f. gather_24).
    return v;
}

SI U32 gather_24(const uint8_t* p, I32 ix) {
    // First, back up a byte.  Any place we're gathering from has a safe junk byte to read
    // in front of it, either a previous table value, or some tag metadata.
    p -= 1;

    // Load the i'th 24-bit value from p, and 1 extra byte.
    auto load_24_32 = [p](int i) {
        return load<uint32_t>(p + 3*i);
    };

    // Now load multiples of 4 bytes (a junk byte, then r,g,b).
#if N == 1
    U32 v = load_24_32(ix);
#elif N == 4
    U32 v = { load_24_32(ix[0]), load_24_32(ix[1]), load_24_32(ix[2]), load_24_32(ix[3]) };
#elif N == 8 && !defined(USING_AVX2)
    U32 v = { load_24_32(ix[0]), load_24_32(ix[1]), load_24_32(ix[2]), load_24_32(ix[3]),
              load_24_32(ix[4]), load_24_32(ix[5]), load_24_32(ix[6]), load_24_32(ix[7]) };
#elif N == 8
    (void)load_24_32;
    // The gather instruction here doesn't need any particular alignment,
    // but the intrinsic takes a const int*.
    const int* p4 = bit_pun<const int*>(p);
    I32 zero = { 0, 0, 0, 0,  0, 0, 0, 0},
        mask = {-1,-1,-1,-1, -1,-1,-1,-1};
    #if defined(__clang__)
        U32 v = (U32)__builtin_ia32_gatherd_d256(zero, p4, 3*ix, mask, 1);
    #elif defined(__GNUC__)
        U32 v = (U32)__builtin_ia32_gathersiv8si(zero, p4, 3*ix, mask, 1);
    #endif
#elif N == 16
    (void)load_24_32;
    // The intrinsic is supposed to take const void* now, but it takes const int*, just like AVX2.
    // And AVX-512 swapped the order of arguments.  :/
    const int* p4 = bit_pun<const int*>(p);
    U32 v = (U32)_mm512_i32gather_epi32((__m512i)(3*ix), p4, 1);
#endif

    // Shift off the junk byte, leaving r,g,b in low 24 bits (and zero in the top 8).
    return v >> 8;
}

#if !defined(__arm__)
    SI void gather_48(const uint8_t* p, I32 ix, U64* v) {
        // As in gather_24(), with everything doubled.
        p -= 2;

        // Load the i'th 48-bit value from p, and 2 extra bytes.
        auto load_48_64 = [p](int i) {
            return load<uint64_t>(p + 6*i);
        };

    #if N == 1
        *v = load_48_64(ix);
    #elif N == 4
        *v = U64{
            load_48_64(ix[0]), load_48_64(ix[1]), load_48_64(ix[2]), load_48_64(ix[3]),
        };
    #elif N == 8 && !defined(USING_AVX2)
        *v = U64{
            load_48_64(ix[0]), load_48_64(ix[1]), load_48_64(ix[2]), load_48_64(ix[3]),
            load_48_64(ix[4]), load_48_64(ix[5]), load_48_64(ix[6]), load_48_64(ix[7]),
        };
    #elif N == 8
        (void)load_48_64;
        typedef int32_t   __attribute__((vector_size(16))) Half_I32;
        typedef long long __attribute__((vector_size(32))) Half_I64;

        // The gather instruction here doesn't need any particular alignment,
        // but the intrinsic takes a const long long*.
        const long long int* p8 = bit_pun<const long long int*>(p);

        Half_I64 zero = { 0, 0, 0, 0},
                 mask = {-1,-1,-1,-1};

        ix *= 6;
        Half_I32 ix_lo = { ix[0], ix[1], ix[2], ix[3] },
                 ix_hi = { ix[4], ix[5], ix[6], ix[7] };

        #if defined(__clang__)
            Half_I64 lo = (Half_I64)__builtin_ia32_gatherd_q256(zero, p8, ix_lo, mask, 1),
                     hi = (Half_I64)__builtin_ia32_gatherd_q256(zero, p8, ix_hi, mask, 1);
        #elif defined(__GNUC__)
            Half_I64 lo = (Half_I64)__builtin_ia32_gathersiv4di(zero, p8, ix_lo, mask, 1),
                     hi = (Half_I64)__builtin_ia32_gathersiv4di(zero, p8, ix_hi, mask, 1);
        #endif
        store((char*)v +  0, lo);
        store((char*)v + 32, hi);
    #elif N == 16
        (void)load_48_64;
        const long long int* p8 = bit_pun<const long long int*>(p);
        __m512i lo = _mm512_i32gather_epi64(_mm512_extracti32x8_epi32((__m512i)(6*ix), 0), p8, 1),
                hi = _mm512_i32gather_epi64(_mm512_extracti32x8_epi32((__m512i)(6*ix), 1), p8, 1);
        store((char*)v +  0, lo);
        store((char*)v + 64, hi);
    #endif

        *v >>= 16;
    }
#endif

SI F F_from_U8(U8 v) {
    return cast<F>(v) * (1/255.0f);
}

SI F F_from_U16_BE(U16 v) {
    // All 16-bit ICC values are big-endian, so we byte swap before converting to float.
    // MSVC catches the "loss" of data here in the portable path, so we also make sure to mask.
    v = (U16)( ((v<<8)|(v>>8)) & 0xffff );
    return cast<F>(v) * (1/65535.0f);
}

SI U16 U16_from_F(F v) {
    // 65535 == inf in FP16, so promote to FP32 before converting.
    return cast<U16>(cast<V<float>>(v) * 65535 + 0.5f);
}

SI F minus_1_ulp(F v) {
#if defined(USING_NEON_FP16)
    return bit_pun<F>( bit_pun<U16>(v) - 1 );
#else
    return bit_pun<F>( bit_pun<U32>(v) - 1 );
#endif
}

SI F table(const skcms_Curve* curve, F v) {
    // Clamp the input to [0,1], then scale to a table index.
    F ix = max_(F0, min_(v, F1)) * (float)(curve->table_entries - 1);

    // We'll look up (equal or adjacent) entries at lo and hi, then lerp by t between the two.
    I32 lo = cast<I32>(            ix      ),
        hi = cast<I32>(minus_1_ulp(ix+1.0f));
    F t = ix - cast<F>(lo);  // i.e. the fractional part of ix.

    // TODO: can we load l and h simultaneously?  Each entry in 'h' is either
    // the same as in 'l' or adjacent.  We have a rough idea that's it'd always be safe
    // to read adjacent entries and perhaps underflow the table by a byte or two
    // (it'd be junk, but always safe to read).  Not sure how to lerp yet.
    F l,h;
    if (curve->table_8) {
        l = F_from_U8(gather_8(curve->table_8, lo));
        h = F_from_U8(gather_8(curve->table_8, hi));
    } else {
        l = F_from_U16_BE(gather_16(curve->table_16, lo));
        h = F_from_U16_BE(gather_16(curve->table_16, hi));
    }
    return l + (h-l)*t;
}

SI void sample_clut_8(const skcms_A2B* a2b, I32 ix, F* r, F* g, F* b) {
    U32 rgb = gather_24(a2b->grid_8, ix);

    *r = cast<F>((rgb >>  0) & 0xff) * (1/255.0f);
    *g = cast<F>((rgb >>  8) & 0xff) * (1/255.0f);
    *b = cast<F>((rgb >> 16) & 0xff) * (1/255.0f);
}

SI void sample_clut_16(const skcms_A2B* a2b, I32 ix, F* r, F* g, F* b) {
#if defined(__arm__)
    // This is up to 2x faster on 32-bit ARM than the #else-case fast path.
    *r = F_from_U16_BE(gather_16(a2b->grid_16, 3*ix+0));
    *g = F_from_U16_BE(gather_16(a2b->grid_16, 3*ix+1));
    *b = F_from_U16_BE(gather_16(a2b->grid_16, 3*ix+2));
#else
    // This strategy is much faster for 64-bit builds, and fine for 32-bit x86 too.
    U64 rgb;
    gather_48(a2b->grid_16, ix, &rgb);
    rgb = swap_endian_16x4(rgb);

    *r = cast<F>((rgb >>  0) & 0xffff) * (1/65535.0f);
    *g = cast<F>((rgb >> 16) & 0xffff) * (1/65535.0f);
    *b = cast<F>((rgb >> 32) & 0xffff) * (1/65535.0f);
#endif
}

// GCC 7.2.0 hits an internal compiler error with -finline-functions (or -O3)
// when targeting MIPS 64,  I think attempting to inline clut() into exec_ops().
#if 1 && defined(__GNUC__) && !defined(__clang__) && defined(__mips64)
    #define MAYBE_NOINLINE __attribute__((noinline))
#else
    #define MAYBE_NOINLINE
#endif

MAYBE_NOINLINE
static void clut(const skcms_A2B* a2b, F* r, F* g, F* b, F a) {
    const int dim = (int)a2b->input_channels;
    assert (0 < dim && dim <= 4);

    // For each of these arrays, think foo[2*dim], but we use foo[8] since we know dim <= 4.
    I32 index [8];  // Index contribution by dimension, first low from 0, then high from 4.
    F   weight[8];  // Weight for each contribution, again first low, then high.

    // O(dim) work first: calculate index,weight from r,g,b,a.
    const F inputs[] = { *r,*g,*b,a };
    for (int i = dim-1, stride = 1; i >= 0; i--) {
        // x is where we logically want to sample the grid in the i-th dimension.
        F x = inputs[i] * (float)(a2b->grid_points[i] - 1);

        // But we can't index at floats.  lo and hi are the two integer grid points surrounding x.
        I32 lo = cast<I32>(            x      ),   // i.e. trunc(x) == floor(x) here.
            hi = cast<I32>(minus_1_ulp(x+1.0f));
        // Notice how we fold in the accumulated stride across previous dimensions here.
        index[i+0] = lo * stride;
        index[i+4] = hi * stride;
        stride *= a2b->grid_points[i];

        // We'll interpolate between those two integer grid points by t.
        F t = x - cast<F>(lo);  // i.e. fract(x)
        weight[i+0] = 1-t;
        weight[i+4] = t;
    }

    *r = *g = *b = F0;

    // We'll sample 2^dim == 1<<dim table entries per pixel,
    // in all combinations of low and high in each dimension.
    for (int combo = 0; combo < (1<<dim); combo++) {  // This loop can be done in any order.

        // Each of these upcoming (combo&N)*K expressions here evaluates to 0 or 4,
        // where 0 selects the low index contribution and its weight 1-t,
        // or 4 the high index contribution and its weight t.

        // Since 0<dim4, we can always just start off with the 0-th channel,
        // then handle the others conditionally.
        I32 ix = index [0 + (combo&1)*4];
        F    w = weight[0 + (combo&1)*4];

        switch ((dim-1)&3) {  // This lets the compiler know there are no other cases to handle.
            case 3: ix += index [3 + (combo&8)/2];
                    w  *= weight[3 + (combo&8)/2];
                    FALLTHROUGH;
                    // fall through

            case 2: ix += index [2 + (combo&4)*1];
                    w  *= weight[2 + (combo&4)*1];
                    FALLTHROUGH;
                    // fall through

            case 1: ix += index [1 + (combo&2)*2];
                    w  *= weight[1 + (combo&2)*2];
        }

        F R,G,B;
        if (a2b->grid_8) {
            sample_clut_8 (a2b,ix, &R,&G,&B);
        } else {
            sample_clut_16(a2b,ix, &R,&G,&B);
        }

        *r += w*R;
        *g += w*G;
        *b += w*B;
    }
}

static void exec_ops(const Op* ops, const void** args,
                     const char* src, char* dst, int i) {
    F r = F0, g = F0, b = F0, a = F1;
    while (true) {
        switch (*ops++) {
            case Op_load_a8:{
                a = F_from_U8(load<U8>(src + 1*i));
            } break;

            case Op_load_g8:{
                r = g = b = F_from_U8(load<U8>(src + 1*i));
            } break;

            case Op_load_4444:{
                U16 abgr = load<U16>(src + 2*i);

                r = cast<F>((abgr >> 12) & 0xf) * (1/15.0f);
                g = cast<F>((abgr >>  8) & 0xf) * (1/15.0f);
                b = cast<F>((abgr >>  4) & 0xf) * (1/15.0f);
                a = cast<F>((abgr >>  0) & 0xf) * (1/15.0f);
            } break;

            case Op_load_565:{
                U16 rgb = load<U16>(src + 2*i);

                r = cast<F>(rgb & (uint16_t)(31<< 0)) * (1.0f / (31<< 0));
                g = cast<F>(rgb & (uint16_t)(63<< 5)) * (1.0f / (63<< 5));
                b = cast<F>(rgb & (uint16_t)(31<<11)) * (1.0f / (31<<11));
            } break;

            case Op_load_888:{
                const uint8_t* rgb = (const uint8_t*)(src + 3*i);
            #if defined(USING_NEON_FP16)
                // See the explanation under USING_NEON below.  This is that doubled up.
                uint8x16x3_t v = {{ vdupq_n_u8(0), vdupq_n_u8(0), vdupq_n_u8(0) }};
                v = vld3q_lane_u8(rgb+ 0, v,  0);
                v = vld3q_lane_u8(rgb+ 3, v,  2);
                v = vld3q_lane_u8(rgb+ 6, v,  4);
                v = vld3q_lane_u8(rgb+ 9, v,  6);

                v = vld3q_lane_u8(rgb+12, v,  8);
                v = vld3q_lane_u8(rgb+15, v, 10);
                v = vld3q_lane_u8(rgb+18, v, 12);
                v = vld3q_lane_u8(rgb+21, v, 14);

                r = cast<F>((U16)v.val[0]) * (1/255.0f);
                g = cast<F>((U16)v.val[1]) * (1/255.0f);
                b = cast<F>((U16)v.val[2]) * (1/255.0f);
            #elif defined(USING_NEON)
                // There's no uint8x4x3_t or vld3 load for it, so we'll load each rgb pixel one at
                // a time.  Since we're doing that, we might as well load them into 16-bit lanes.
                // (We'd even load into 32-bit lanes, but that's not possible on ARMv7.)
                uint8x8x3_t v = {{ vdup_n_u8(0), vdup_n_u8(0), vdup_n_u8(0) }};
                v = vld3_lane_u8(rgb+0, v, 0);
                v = vld3_lane_u8(rgb+3, v, 2);
                v = vld3_lane_u8(rgb+6, v, 4);
                v = vld3_lane_u8(rgb+9, v, 6);

                // Now if we squint, those 3 uint8x8_t we constructed are really U16s, easy to
                // convert to F.  (Again, U32 would be even better here if drop ARMv7 or split
                // ARMv7 and ARMv8 impls.)
                r = cast<F>((U16)v.val[0]) * (1/255.0f);
                g = cast<F>((U16)v.val[1]) * (1/255.0f);
                b = cast<F>((U16)v.val[2]) * (1/255.0f);
            #else
                r = cast<F>(load_3<U32>(rgb+0) ) * (1/255.0f);
                g = cast<F>(load_3<U32>(rgb+1) ) * (1/255.0f);
                b = cast<F>(load_3<U32>(rgb+2) ) * (1/255.0f);
            #endif
            } break;

            case Op_load_8888:{
                U32 rgba = load<U32>(src + 4*i);

                r = cast<F>((rgba >>  0) & 0xff) * (1/255.0f);
                g = cast<F>((rgba >>  8) & 0xff) * (1/255.0f);
                b = cast<F>((rgba >> 16) & 0xff) * (1/255.0f);
                a = cast<F>((rgba >> 24) & 0xff) * (1/255.0f);
            } break;

            case Op_load_8888_palette8:{
                const uint8_t* palette = (const uint8_t*) *args++;
                I32 ix = cast<I32>(load<U8>(src + 1*i));
                U32 rgba = gather_32(palette, ix);

                r = cast<F>((rgba >>  0) & 0xff) * (1/255.0f);
                g = cast<F>((rgba >>  8) & 0xff) * (1/255.0f);
                b = cast<F>((rgba >> 16) & 0xff) * (1/255.0f);
                a = cast<F>((rgba >> 24) & 0xff) * (1/255.0f);
            } break;

            case Op_load_1010102:{
                U32 rgba = load<U32>(src + 4*i);

                r = cast<F>((rgba >>  0) & 0x3ff) * (1/1023.0f);
                g = cast<F>((rgba >> 10) & 0x3ff) * (1/1023.0f);
                b = cast<F>((rgba >> 20) & 0x3ff) * (1/1023.0f);
                a = cast<F>((rgba >> 30) & 0x3  ) * (1/   3.0f);
            } break;

            case Op_load_161616LE:{
                uintptr_t ptr = (uintptr_t)(src + 6*i);
                assert( (ptr & 1) == 0 );                   // src must be 2-byte aligned for this
                const uint16_t* rgb = (const uint16_t*)ptr; // cast to const uint16_t* to be safe.
            #if defined(USING_NEON_FP16)
                uint16x8x3_t v = vld3q_u16(rgb);
                r = cast<F>((U16)v.val[0]) * (1/65535.0f);
                g = cast<F>((U16)v.val[1]) * (1/65535.0f);
                b = cast<F>((U16)v.val[2]) * (1/65535.0f);
            #elif defined(USING_NEON)
                uint16x4x3_t v = vld3_u16(rgb);
                r = cast<F>((U16)v.val[0]) * (1/65535.0f);
                g = cast<F>((U16)v.val[1]) * (1/65535.0f);
                b = cast<F>((U16)v.val[2]) * (1/65535.0f);
            #else
                r = cast<F>(load_3<U32>(rgb+0)) * (1/65535.0f);
                g = cast<F>(load_3<U32>(rgb+1)) * (1/65535.0f);
                b = cast<F>(load_3<U32>(rgb+2)) * (1/65535.0f);
            #endif
            } break;

            case Op_load_16161616LE:{
                uintptr_t ptr = (uintptr_t)(src + 8*i);
                assert( (ptr & 1) == 0 );                    // src must be 2-byte aligned for this
                const uint16_t* rgba = (const uint16_t*)ptr; // cast to const uint16_t* to be safe.
            #if defined(USING_NEON_FP16)
                uint16x8x4_t v = vld4q_u16(rgba);
                r = cast<F>((U16)v.val[0]) * (1/65535.0f);
                g = cast<F>((U16)v.val[1]) * (1/65535.0f);
                b = cast<F>((U16)v.val[2]) * (1/65535.0f);
                a = cast<F>((U16)v.val[3]) * (1/65535.0f);
            #elif defined(USING_NEON)
                uint16x4x4_t v = vld4_u16(rgba);
                r = cast<F>((U16)v.val[0]) * (1/65535.0f);
                g = cast<F>((U16)v.val[1]) * (1/65535.0f);
                b = cast<F>((U16)v.val[2]) * (1/65535.0f);
                a = cast<F>((U16)v.val[3]) * (1/65535.0f);
            #else
                U64 px = load<U64>(rgba);

                r = cast<F>((px >>  0) & 0xffff) * (1/65535.0f);
                g = cast<F>((px >> 16) & 0xffff) * (1/65535.0f);
                b = cast<F>((px >> 32) & 0xffff) * (1/65535.0f);
                a = cast<F>((px >> 48) & 0xffff) * (1/65535.0f);
            #endif
            } break;

            case Op_load_161616BE:{
                uintptr_t ptr = (uintptr_t)(src + 6*i);
                assert( (ptr & 1) == 0 );                   // src must be 2-byte aligned for this
                const uint16_t* rgb = (const uint16_t*)ptr; // cast to const uint16_t* to be safe.
            #if defined(USING_NEON_FP16)
                uint16x8x3_t v = vld3q_u16(rgb);
                r = cast<F>(swap_endian_16((U16)v.val[0])) * (1/65535.0f);
                g = cast<F>(swap_endian_16((U16)v.val[1])) * (1/65535.0f);
                b = cast<F>(swap_endian_16((U16)v.val[2])) * (1/65535.0f);
            #elif defined(USING_NEON)
                uint16x4x3_t v = vld3_u16(rgb);
                r = cast<F>(swap_endian_16((U16)v.val[0])) * (1/65535.0f);
                g = cast<F>(swap_endian_16((U16)v.val[1])) * (1/65535.0f);
                b = cast<F>(swap_endian_16((U16)v.val[2])) * (1/65535.0f);
            #else
                U32 R = load_3<U32>(rgb+0),
                    G = load_3<U32>(rgb+1),
                    B = load_3<U32>(rgb+2);
                // R,G,B are big-endian 16-bit, so byte swap them before converting to float.
                r = cast<F>((R & 0x00ff)<<8 | (R & 0xff00)>>8) * (1/65535.0f);
                g = cast<F>((G & 0x00ff)<<8 | (G & 0xff00)>>8) * (1/65535.0f);
                b = cast<F>((B & 0x00ff)<<8 | (B & 0xff00)>>8) * (1/65535.0f);
            #endif
            } break;

            case Op_load_16161616BE:{
                uintptr_t ptr = (uintptr_t)(src + 8*i);
                assert( (ptr & 1) == 0 );                    // src must be 2-byte aligned for this
                const uint16_t* rgba = (const uint16_t*)ptr; // cast to const uint16_t* to be safe.
            #if defined(USING_NEON_FP16)
                uint16x8x4_t v = vld4q_u16(rgba);
                r = cast<F>(swap_endian_16((U16)v.val[0])) * (1/65535.0f);
                g = cast<F>(swap_endian_16((U16)v.val[1])) * (1/65535.0f);
                b = cast<F>(swap_endian_16((U16)v.val[2])) * (1/65535.0f);
                a = cast<F>(swap_endian_16((U16)v.val[3])) * (1/65535.0f);
            #elif defined(USING_NEON)
                uint16x4x4_t v = vld4_u16(rgba);
                r = cast<F>(swap_endian_16((U16)v.val[0])) * (1/65535.0f);
                g = cast<F>(swap_endian_16((U16)v.val[1])) * (1/65535.0f);
                b = cast<F>(swap_endian_16((U16)v.val[2])) * (1/65535.0f);
                a = cast<F>(swap_endian_16((U16)v.val[3])) * (1/65535.0f);
            #else
                U64 px = swap_endian_16x4(load<U64>(rgba));

                r = cast<F>((px >>  0) & 0xffff) * (1/65535.0f);
                g = cast<F>((px >> 16) & 0xffff) * (1/65535.0f);
                b = cast<F>((px >> 32) & 0xffff) * (1/65535.0f);
                a = cast<F>((px >> 48) & 0xffff) * (1/65535.0f);
            #endif
            } break;

            case Op_load_hhh:{
                uintptr_t ptr = (uintptr_t)(src + 6*i);
                assert( (ptr & 1) == 0 );                   // src must be 2-byte aligned for this
                const uint16_t* rgb = (const uint16_t*)ptr; // cast to const uint16_t* to be safe.
            #if defined(USING_NEON_FP16)
                uint16x8x3_t v = vld3q_u16(rgb);
                U16 R = (U16)v.val[0],
                    G = (U16)v.val[1],
                    B = (U16)v.val[2];
            #elif defined(USING_NEON)
                uint16x4x3_t v = vld3_u16(rgb);
                U16 R = (U16)v.val[0],
                    G = (U16)v.val[1],
                    B = (U16)v.val[2];
            #else
                U16 R = load_3<U16>(rgb+0),
                    G = load_3<U16>(rgb+1),
                    B = load_3<U16>(rgb+2);
            #endif
                r = F_from_Half(R);
                g = F_from_Half(G);
                b = F_from_Half(B);
            } break;

            case Op_load_hhhh:{
                uintptr_t ptr = (uintptr_t)(src + 8*i);
                assert( (ptr & 1) == 0 );                    // src must be 2-byte aligned for this
                const uint16_t* rgba = (const uint16_t*)ptr; // cast to const uint16_t* to be safe.
            #if defined(USING_NEON_FP16)
                uint16x8x4_t v = vld4q_u16(rgba);
                U16 R = (U16)v.val[0],
                    G = (U16)v.val[1],
                    B = (U16)v.val[2],
                    A = (U16)v.val[3];
            #elif defined(USING_NEON)
                uint16x4x4_t v = vld4_u16(rgba);
                U16 R = (U16)v.val[0],
                    G = (U16)v.val[1],
                    B = (U16)v.val[2],
                    A = (U16)v.val[3];
            #else
                U64 px = load<U64>(rgba);
                U16 R = cast<U16>((px >>  0) & 0xffff),
                    G = cast<U16>((px >> 16) & 0xffff),
                    B = cast<U16>((px >> 32) & 0xffff),
                    A = cast<U16>((px >> 48) & 0xffff);
            #endif
                r = F_from_Half(R);
                g = F_from_Half(G);
                b = F_from_Half(B);
                a = F_from_Half(A);
            } break;

            case Op_load_fff:{
                uintptr_t ptr = (uintptr_t)(src + 12*i);
                assert( (ptr & 3) == 0 );                   // src must be 4-byte aligned for this
                const float* rgb = (const float*)ptr;       // cast to const float* to be safe.
            #if defined(USING_NEON_FP16)
                float32x4x3_t lo = vld3q_f32(rgb +  0),
                              hi = vld3q_f32(rgb + 12);
                r = (F)vcombine_f16(vcvt_f16_f32(lo.val[0]), vcvt_f16_f32(hi.val[0]));
                g = (F)vcombine_f16(vcvt_f16_f32(lo.val[1]), vcvt_f16_f32(hi.val[1]));
                b = (F)vcombine_f16(vcvt_f16_f32(lo.val[2]), vcvt_f16_f32(hi.val[2]));
            #elif defined(USING_NEON)
                float32x4x3_t v = vld3q_f32(rgb);
                r = (F)v.val[0];
                g = (F)v.val[1];
                b = (F)v.val[2];
            #else
                r = load_3<F>(rgb+0);
                g = load_3<F>(rgb+1);
                b = load_3<F>(rgb+2);
            #endif
            } break;

            case Op_load_ffff:{
                uintptr_t ptr = (uintptr_t)(src + 16*i);
                assert( (ptr & 3) == 0 );                   // src must be 4-byte aligned for this
                const float* rgba = (const float*)ptr;      // cast to const float* to be safe.
            #if defined(USING_NEON_FP16)
                float32x4x4_t lo = vld4q_f32(rgba +  0),
                              hi = vld4q_f32(rgba + 16);
                r = (F)vcombine_f16(vcvt_f16_f32(lo.val[0]), vcvt_f16_f32(hi.val[0]));
                g = (F)vcombine_f16(vcvt_f16_f32(lo.val[1]), vcvt_f16_f32(hi.val[1]));
                b = (F)vcombine_f16(vcvt_f16_f32(lo.val[2]), vcvt_f16_f32(hi.val[2]));
                a = (F)vcombine_f16(vcvt_f16_f32(lo.val[3]), vcvt_f16_f32(hi.val[3]));
            #elif defined(USING_NEON)
                float32x4x4_t v = vld4q_f32(rgba);
                r = (F)v.val[0];
                g = (F)v.val[1];
                b = (F)v.val[2];
                a = (F)v.val[3];
            #else
                r = load_4<F>(rgba+0);
                g = load_4<F>(rgba+1);
                b = load_4<F>(rgba+2);
                a = load_4<F>(rgba+3);
            #endif
            } break;

            case Op_swap_rb:{
                F t = r;
                r = b;
                b = t;
            } break;

            case Op_clamp:{
                r = max_(F0, min_(r, F1));
                g = max_(F0, min_(g, F1));
                b = max_(F0, min_(b, F1));
                a = max_(F0, min_(a, F1));
            } break;

            case Op_invert:{
                r = F1 - r;
                g = F1 - g;
                b = F1 - b;
                a = F1 - a;
            } break;

            case Op_force_opaque:{
                a = F1;
            } break;

            case Op_premul:{
                r *= a;
                g *= a;
                b *= a;
            } break;

            case Op_unpremul:{
                F scale = if_then_else(F1 / a < INFINITY_, F1 / a, F0);
                r *= scale;
                g *= scale;
                b *= scale;
            } break;

            case Op_matrix_3x3:{
                const skcms_Matrix3x3* matrix = (const skcms_Matrix3x3*) *args++;
                const float* m = &matrix->vals[0][0];

                F R = m[0]*r + m[1]*g + m[2]*b,
                  G = m[3]*r + m[4]*g + m[5]*b,
                  B = m[6]*r + m[7]*g + m[8]*b;

                r = R;
                g = G;
                b = B;
            } break;

            case Op_matrix_3x4:{
                const skcms_Matrix3x4* matrix = (const skcms_Matrix3x4*) *args++;
                const float* m = &matrix->vals[0][0];

                F R = m[0]*r + m[1]*g + m[ 2]*b + m[ 3],
                  G = m[4]*r + m[5]*g + m[ 6]*b + m[ 7],
                  B = m[8]*r + m[9]*g + m[10]*b + m[11];

                r = R;
                g = G;
                b = B;
            } break;

            case Op_lab_to_xyz:{
                // The L*a*b values are in r,g,b, but normalized to [0,1].  Reconstruct them:
                F L = r * 100.0f,
                  A = g * 255.0f - 128.0f,
                  B = b * 255.0f - 128.0f;

                // Convert to CIE XYZ.
                F Y = (L + 16.0f) * (1/116.0f),
                  X = Y + A*(1/500.0f),
                  Z = Y - B*(1/200.0f);

                X = if_then_else(X*X*X > 0.008856f, X*X*X, (X - (16/116.0f)) * (1/7.787f));
                Y = if_then_else(Y*Y*Y > 0.008856f, Y*Y*Y, (Y - (16/116.0f)) * (1/7.787f));
                Z = if_then_else(Z*Z*Z > 0.008856f, Z*Z*Z, (Z - (16/116.0f)) * (1/7.787f));

                // Adjust to XYZD50 illuminant, and stuff back into r,g,b for the next op.
                r = X * 0.9642f;
                g = Y          ;
                b = Z * 0.8249f;
            } break;

            case Op_tf_r:{ r = apply_tf((const skcms_TransferFunction*)*args++, r); } break;
            case Op_tf_g:{ g = apply_tf((const skcms_TransferFunction*)*args++, g); } break;
            case Op_tf_b:{ b = apply_tf((const skcms_TransferFunction*)*args++, b); } break;
            case Op_tf_a:{ a = apply_tf((const skcms_TransferFunction*)*args++, a); } break;

            case Op_table_r: { r = table((const skcms_Curve*)*args++, r); } break;
            case Op_table_g: { g = table((const skcms_Curve*)*args++, g); } break;
            case Op_table_b: { b = table((const skcms_Curve*)*args++, b); } break;
            case Op_table_a: { a = table((const skcms_Curve*)*args++, a); } break;

            case Op_clut: {
                const skcms_A2B* a2b = (const skcms_A2B*) *args++;
                clut(a2b, &r,&g,&b,a);

                if (a2b->input_channels == 4) {
                    // CMYK is opaque.
                    a = F1;
                }
            } break;

    // Notice, from here on down the store_ ops all return, ending the loop.

            case Op_store_a8: {
                store(dst + 1*i, cast<U8>(to_fixed(a * 255)));
            } return;

            case Op_store_g8: {
                // g should be holding luminance (Y) (r,g,b ~~~> X,Y,Z)
                store(dst + 1*i, cast<U8>(to_fixed(g * 255)));
            } return;

            case Op_store_4444: {
                store<U16>(dst + 2*i, cast<U16>(to_fixed(r * 15) << 12)
                                    | cast<U16>(to_fixed(g * 15) <<  8)
                                    | cast<U16>(to_fixed(b * 15) <<  4)
                                    | cast<U16>(to_fixed(a * 15) <<  0));
            } return;

            case Op_store_565: {
                store<U16>(dst + 2*i, cast<U16>(to_fixed(r * 31) <<  0 )
                                    | cast<U16>(to_fixed(g * 63) <<  5 )
                                    | cast<U16>(to_fixed(b * 31) << 11 ));
            } return;

            case Op_store_888: {
                uint8_t* rgb = (uint8_t*)dst + 3*i;
            #if defined(USING_NEON_FP16)
                // See the explanation under USING_NEON below.  This is that doubled up.
                U16 R = to_fixed(r * 255),
                    G = to_fixed(g * 255),
                    B = to_fixed(b * 255);

                uint8x16x3_t v = {{ (uint8x16_t)R, (uint8x16_t)G, (uint8x16_t)B }};
                vst3q_lane_u8(rgb+ 0, v,  0);
                vst3q_lane_u8(rgb+ 3, v,  2);
                vst3q_lane_u8(rgb+ 6, v,  4);
                vst3q_lane_u8(rgb+ 9, v,  6);

                vst3q_lane_u8(rgb+12, v,  8);
                vst3q_lane_u8(rgb+15, v, 10);
                vst3q_lane_u8(rgb+18, v, 12);
                vst3q_lane_u8(rgb+21, v, 14);
            #elif defined(USING_NEON)
                // Same deal as load_888 but in reverse... we'll store using uint8x8x3_t, but
                // get there via U16 to save some instructions converting to float.  And just
                // like load_888, we'd prefer to go via U32 but for ARMv7 support.
                U16 R = cast<U16>(to_fixed(r * 255)),
                    G = cast<U16>(to_fixed(g * 255)),
                    B = cast<U16>(to_fixed(b * 255));

                uint8x8x3_t v = {{ (uint8x8_t)R, (uint8x8_t)G, (uint8x8_t)B }};
                vst3_lane_u8(rgb+0, v, 0);
                vst3_lane_u8(rgb+3, v, 2);
                vst3_lane_u8(rgb+6, v, 4);
                vst3_lane_u8(rgb+9, v, 6);
            #else
                store_3(rgb+0, cast<U8>(to_fixed(r * 255)) );
                store_3(rgb+1, cast<U8>(to_fixed(g * 255)) );
                store_3(rgb+2, cast<U8>(to_fixed(b * 255)) );
            #endif
            } return;

            case Op_store_8888: {
                store(dst + 4*i, cast<U32>(to_fixed(r * 255)) <<  0
                               | cast<U32>(to_fixed(g * 255)) <<  8
                               | cast<U32>(to_fixed(b * 255)) << 16
                               | cast<U32>(to_fixed(a * 255)) << 24);
            } return;

            case Op_store_1010102: {
                store(dst + 4*i, cast<U32>(to_fixed(r * 1023)) <<  0
                               | cast<U32>(to_fixed(g * 1023)) << 10
                               | cast<U32>(to_fixed(b * 1023)) << 20
                               | cast<U32>(to_fixed(a *    3)) << 30);
            } return;

            case Op_store_161616LE: {
                uintptr_t ptr = (uintptr_t)(dst + 6*i);
                assert( (ptr & 1) == 0 );                // The dst pointer must be 2-byte aligned
                uint16_t* rgb = (uint16_t*)ptr;          // for this cast to uint16_t* to be safe.
            #if defined(USING_NEON_FP16)
                uint16x8x3_t v = {{
                    (uint16x8_t)U16_from_F(r),
                    (uint16x8_t)U16_from_F(g),
                    (uint16x8_t)U16_from_F(b),
                }};
                vst3q_u16(rgb, v);
            #elif defined(USING_NEON)
                uint16x4x3_t v = {{
                    (uint16x4_t)U16_from_F(r),
                    (uint16x4_t)U16_from_F(g),
                    (uint16x4_t)U16_from_F(b),
                }};
                vst3_u16(rgb, v);
            #else
                store_3(rgb+0, U16_from_F(r));
                store_3(rgb+1, U16_from_F(g));
                store_3(rgb+2, U16_from_F(b));
            #endif

            } return;

            case Op_store_16161616LE: {
                uintptr_t ptr = (uintptr_t)(dst + 8*i);
                assert( (ptr & 1) == 0 );               // The dst pointer must be 2-byte aligned
                uint16_t* rgba = (uint16_t*)ptr;        // for this cast to uint16_t* to be safe.
            #if defined(USING_NEON_FP16)
                uint16x8x4_t v = {{
                    (uint16x8_t)U16_from_F(r),
                    (uint16x8_t)U16_from_F(g),
                    (uint16x8_t)U16_from_F(b),
                    (uint16x8_t)U16_from_F(a),
                }};
                vst4q_u16(rgba, v);
            #elif defined(USING_NEON)
                uint16x4x4_t v = {{
                    (uint16x4_t)U16_from_F(r),
                    (uint16x4_t)U16_from_F(g),
                    (uint16x4_t)U16_from_F(b),
                    (uint16x4_t)U16_from_F(a),
                }};
                vst4_u16(rgba, v);
            #else
                U64 px = cast<U64>(to_fixed(r * 65535)) <<  0
                       | cast<U64>(to_fixed(g * 65535)) << 16
                       | cast<U64>(to_fixed(b * 65535)) << 32
                       | cast<U64>(to_fixed(a * 65535)) << 48;
                store(rgba, px);
            #endif
            } return;

            case Op_store_161616BE: {
                uintptr_t ptr = (uintptr_t)(dst + 6*i);
                assert( (ptr & 1) == 0 );                // The dst pointer must be 2-byte aligned
                uint16_t* rgb = (uint16_t*)ptr;          // for this cast to uint16_t* to be safe.
            #if defined(USING_NEON_FP16)
                uint16x8x3_t v = {{
                    (uint16x8_t)swap_endian_16(U16_from_F(r)),
                    (uint16x8_t)swap_endian_16(U16_from_F(g)),
                    (uint16x8_t)swap_endian_16(U16_from_F(b)),
                }};
                vst3q_u16(rgb, v);
            #elif defined(USING_NEON)
                uint16x4x3_t v = {{
                    (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(r))),
                    (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(g))),
                    (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(b))),
                }};
                vst3_u16(rgb, v);
            #else
                U32 R = to_fixed(r * 65535),
                    G = to_fixed(g * 65535),
                    B = to_fixed(b * 65535);
                store_3(rgb+0, cast<U16>((R & 0x00ff) << 8 | (R & 0xff00) >> 8) );
                store_3(rgb+1, cast<U16>((G & 0x00ff) << 8 | (G & 0xff00) >> 8) );
                store_3(rgb+2, cast<U16>((B & 0x00ff) << 8 | (B & 0xff00) >> 8) );
            #endif

            } return;

            case Op_store_16161616BE: {
                uintptr_t ptr = (uintptr_t)(dst + 8*i);
                assert( (ptr & 1) == 0 );               // The dst pointer must be 2-byte aligned
                uint16_t* rgba = (uint16_t*)ptr;        // for this cast to uint16_t* to be safe.
            #if defined(USING_NEON_FP16)
                uint16x8x4_t v = {{
                    (uint16x8_t)swap_endian_16(U16_from_F(r)),
                    (uint16x8_t)swap_endian_16(U16_from_F(g)),
                    (uint16x8_t)swap_endian_16(U16_from_F(b)),
                    (uint16x8_t)swap_endian_16(U16_from_F(a)),
                }};
                vst4q_u16(rgba, v);
            #elif defined(USING_NEON)
                uint16x4x4_t v = {{
                    (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(r))),
                    (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(g))),
                    (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(b))),
                    (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(a))),
                }};
                vst4_u16(rgba, v);
            #else
                U64 px = cast<U64>(to_fixed(r * 65535)) <<  0
                       | cast<U64>(to_fixed(g * 65535)) << 16
                       | cast<U64>(to_fixed(b * 65535)) << 32
                       | cast<U64>(to_fixed(a * 65535)) << 48;
                store(rgba, swap_endian_16x4(px));
            #endif
            } return;

            case Op_store_hhh: {
                uintptr_t ptr = (uintptr_t)(dst + 6*i);
                assert( (ptr & 1) == 0 );                // The dst pointer must be 2-byte aligned
                uint16_t* rgb = (uint16_t*)ptr;          // for this cast to uint16_t* to be safe.

                U16 R = Half_from_F(r),
                    G = Half_from_F(g),
                    B = Half_from_F(b);
            #if defined(USING_NEON_FP16)
                uint16x8x3_t v = {{
                    (uint16x8_t)R,
                    (uint16x8_t)G,
                    (uint16x8_t)B,
                }};
                vst3q_u16(rgb, v);
            #elif defined(USING_NEON)
                uint16x4x3_t v = {{
                    (uint16x4_t)R,
                    (uint16x4_t)G,
                    (uint16x4_t)B,
                }};
                vst3_u16(rgb, v);
            #else
                store_3(rgb+0, R);
                store_3(rgb+1, G);
                store_3(rgb+2, B);
            #endif
            } return;

            case Op_store_hhhh: {
                uintptr_t ptr = (uintptr_t)(dst + 8*i);
                assert( (ptr & 1) == 0 );                // The dst pointer must be 2-byte aligned
                uint16_t* rgba = (uint16_t*)ptr;         // for this cast to uint16_t* to be safe.

                U16 R = Half_from_F(r),
                    G = Half_from_F(g),
                    B = Half_from_F(b),
                    A = Half_from_F(a);
            #if defined(USING_NEON_FP16)
                uint16x8x4_t v = {{
                    (uint16x8_t)R,
                    (uint16x8_t)G,
                    (uint16x8_t)B,
                    (uint16x8_t)A,
                }};
                vst4q_u16(rgba, v);
            #elif defined(USING_NEON)
                uint16x4x4_t v = {{
                    (uint16x4_t)R,
                    (uint16x4_t)G,
                    (uint16x4_t)B,
                    (uint16x4_t)A,
                }};
                vst4_u16(rgba, v);
            #else
                store(rgba, cast<U64>(R) <<  0
                          | cast<U64>(G) << 16
                          | cast<U64>(B) << 32
                          | cast<U64>(A) << 48);
            #endif

            } return;

            case Op_store_fff: {
                uintptr_t ptr = (uintptr_t)(dst + 12*i);
                assert( (ptr & 3) == 0 );                // The dst pointer must be 4-byte aligned
                float* rgb = (float*)ptr;                // for this cast to float* to be safe.
            #if defined(USING_NEON_FP16)
                float32x4x3_t lo = {{
                    vcvt_f32_f16(vget_low_f16(r)),
                    vcvt_f32_f16(vget_low_f16(g)),
                    vcvt_f32_f16(vget_low_f16(b)),
                }}, hi = {{
                    vcvt_f32_f16(vget_high_f16(r)),
                    vcvt_f32_f16(vget_high_f16(g)),
                    vcvt_f32_f16(vget_high_f16(b)),
                }};
                vst3q_f32(rgb +  0, lo);
                vst3q_f32(rgb + 12, hi);
            #elif defined(USING_NEON)
                float32x4x3_t v = {{
                    (float32x4_t)r,
                    (float32x4_t)g,
                    (float32x4_t)b,
                }};
                vst3q_f32(rgb, v);
            #else
                store_3(rgb+0, r);
                store_3(rgb+1, g);
                store_3(rgb+2, b);
            #endif
            } return;

            case Op_store_ffff: {
                uintptr_t ptr = (uintptr_t)(dst + 16*i);
                assert( (ptr & 3) == 0 );                // The dst pointer must be 4-byte aligned
                float* rgba = (float*)ptr;               // for this cast to float* to be safe.
            #if defined(USING_NEON_FP16)
                float32x4x4_t lo = {{
                    vcvt_f32_f16(vget_low_f16(r)),
                    vcvt_f32_f16(vget_low_f16(g)),
                    vcvt_f32_f16(vget_low_f16(b)),
                    vcvt_f32_f16(vget_low_f16(a)),
                }}, hi = {{
                    vcvt_f32_f16(vget_high_f16(r)),
                    vcvt_f32_f16(vget_high_f16(g)),
                    vcvt_f32_f16(vget_high_f16(b)),
                    vcvt_f32_f16(vget_high_f16(a)),
                }};
                vst4q_f32(rgba +  0, lo);
                vst4q_f32(rgba + 16, hi);
            #elif defined(USING_NEON)
                float32x4x4_t v = {{
                    (float32x4_t)r,
                    (float32x4_t)g,
                    (float32x4_t)b,
                    (float32x4_t)a,
                }};
                vst4q_f32(rgba, v);
            #else
                store_4(rgba+0, r);
                store_4(rgba+1, g);
                store_4(rgba+2, b);
                store_4(rgba+3, a);
            #endif
            } return;
        }
    }
}


static void run_program(const Op* program, const void** arguments,
                        const char* src, char* dst, int n,
                        const size_t src_bpp, const size_t dst_bpp) {
    int i = 0;
    while (n >= N) {
        exec_ops(program, arguments, src, dst, i);
        i += N;
        n -= N;
    }
    if (n > 0) {
        char tmp[4*4*N] = {0};

        memcpy(tmp, (const char*)src + (size_t)i*src_bpp, (size_t)n*src_bpp);
        exec_ops(program, arguments, tmp, tmp, 0);
        memcpy((char*)dst + (size_t)i*dst_bpp, tmp, (size_t)n*dst_bpp);
    }
}

// Clean up any #defines we may have set so that we can be #included again.
#if defined(USING_AVX)
    #undef  USING_AVX
#endif
#if defined(USING_AVX_F16C)
    #undef  USING_AVX_F16C
#endif
#if defined(USING_AVX2)
    #undef  USING_AVX2
#endif
#if defined(USING_AVX512F)
    #undef  USING_AVX512F
#endif

#if defined(USING_NEON)
    #undef  USING_NEON
#endif
#if defined(USING_NEON_F16C)
    #undef  USING_NEON_F16C
#endif
#if defined(USING_NEON_FP16)
    #undef  USING_NEON_FP16
#endif

#undef FALLTHROUGH
